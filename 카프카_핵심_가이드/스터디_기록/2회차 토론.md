📝 Kafka 정리
1️⃣ 컨슈머 그룹은 꼭 있어야 할까?

컨슈머 그룹은 없어도 동작 가능하지만, 일반적으로 사용하는 것이 맞다 ✅

group.id 기반으로 묶여 동작한다.

같은 group.id를 공유하면 그룹으로 묶이고, 파티션이 분배된다 ⚖️

Kafka가 오프셋을 그룹 단위로 관리하며, 컨슈머 장애 시 리밸런싱으로 이어받는다 🔄

따라서 스케일 아웃(확장) ⚡, 내결함성 💪을 위해 거의 항상 그룹을 사용한다.

2️⃣ 하나의 메시지를 여러 컨슈머가 각각 처리하려면?

컨슈머마다 group.id를 다르게 가져가야 한다 🎯
→ 컨슈머마다 별도 그룹 생성

같은 그룹은 동일 오프셋 공유.

보통 group.id는 서비스 단위로 생성한다.

예: alarmService, orderService

3️⃣ 트랜잭션 아웃박스 패턴

📌 개요
이벤트를 발행하기 전에 Outbox 테이블에 저장 → 트랜잭션 내에서 정합성 보장.

✅ 장점

이벤트 발행의 유일성 보장 🔒

트랜잭션 범위 내에서 안정성 확보

⚠️ 단점

관리 포인트 증가 🗂️

Outbox 테이블을 처리할 추가 프로세스 필요 (배치, 이벤트 릴레이 등)

4️⃣ Kafka Streams

Kafka 기반의 스트리밍 데이터 처리 라이브러리 🌊

참고 자료:

🏠 Bucketplace 사례

💬 LINE 사례

5️⃣ 그룹 코디네이터 정의

그룹 코디네이터는 Kafka 브로커 내에 위치 🖥️

각 컨슈머 그룹마다 하나씩 존재 (컨슈머 그룹 = 1 : 1 = 그룹 코디네이터)

__consumer_offsets 내부 토픽의 파티션 리더 브로커가 담당

6️⃣ 그룹 코디네이터 개수 및 구조

컨슈머 그룹마다 그룹 코디네이터가 하나씩 존재
👉 컨슈머 그룹 : 그룹 코디네이터 = 1 : 1
👉 컨슈머 그룹 : 컨슈머 = 1 : N

### 아키텍처
```
브로커 1
 ├─ 그룹코디네이터: 그룹A
 │     ├─ 컨슈머1
 │     └─ 컨슈머2
 ├─ 그룹코디네이터: 그룹B
 │     └─ 컨슈머3
 └─ 그룹코디네이터: 그룹C
       ├─ 컨슈머4
       └─ 컨슈머5

브로커 2
 ├─ 그룹코디네이터: 그룹D
 │     ├─ 컨슈머6
 │     └─ 컨슈머7
 └─ 그룹코디네이터: 그룹E
       └─ 컨슈머8

브로커 3
 └─ 그룹코디네이터: 그룹F
       ├─ 컨슈머9
       └─ 컨슈머10
```
