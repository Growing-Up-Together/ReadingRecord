# 7장. 데이터 암호화

[MySQL 8.0 Reference Manual](https://dev.mysql.com/doc/refman/8.0/en/)

[1. MySQL 서버의 데이터 암호화](#1-mysql-서버의-데이터-암호화)  
[2. keyring_file 플러그인 설치](#2-keyringfile-플러그인-설치)  
[3. 테이블 암호화](#3-테이블-암호화)  
[4. 언두 로그 및 리두 로그 암호화](#4-언두-로그-및-리두-로그-암호화)  
[5. 바이너리 로그 암호화](#5-바이너리-로그-암호화)

## 1. MySQL 서버의 데이터 암호화

- MySQL5.7 버전부터 암호화를 지원
    - 데이터 파일(테이블스페이스)에 대해서만 암호화
- MySQL8.0 버전
    - 데이터 파일(테이블스페이스)에 대해서만 암호화
    - 리두 로그, 언두 로그 암호화
    - 복제를 위한 바이너리 로그 암호화

#### 데이터 암호화의 필요성

- 데이터 암호화 여부는 보안 감사에서 필수적으로 언급된다.
- 중요한 정보를 저장하는 서비스에서는 응용 프로그램에서 암호화한 데이터를 DB 서버에서 다시 암호화 하는 이중 암호화를 선택하기도 한다. (e.g. 핀테크)
- **응용 프로그램의 암호화는 주요 정보를 가진 컬럼 단위이지만, DB 수준에서는 테이블 단위로 암호화를 적용한다.**

#### TDE (Transparent Data Encryption) (= Data at Rest Encryption)

- MySQL 서버의 암호화 기능은 데이터베이스 서버와 디스크 사이의 데이터를 읽고 쓰는 지점에서 암호화 또는 복호화를 수행한다.  
  **→ MySQL 서버의 I/O 레이어에서만 데이터의 암호화 및 복호화 과정이 실행된다.**
- 따라서 쿼리를 처리하는 과정에서 테이블이 암호화 되어 있는지 여부는 식별할 필요가 없다.

### 2 단계 키 관리

- TDE에서 암호화는 키링(KeyRing) 플러그인에 의해 관리된다.
- MySQL8.0 버전에서 다양한 키링 플러그인이 제공되며, 마스터 키를 관리하는 방식이 다를 뿐 내부적으로 작동하는 방식은 모두 동일하다.
    - keyring_file File-Based 플러그인 _(→ 커뮤니티 에디션에서 사용 가능)_
    - keyring_encrypted_file Keyring 플러그인
    - keyring_okv KMIP 플러그인
    - keyring_aws Amazon Web Services Keyring 플러그인

- 키링 플러그인은 2단계 키 관리 방식을 사용한다.
    - MySQL 서버의 데이터 암호화는 두 가지 종류의 키를 가지고 있다.
        - 마스터 키(master key)
        - 테이블스페이스 키(tablespace key) = 프라이빗 키(private key)
    - MySQL 서버는 HashiCorp Vault 같은 외부 키 관리 솔루션(KMS) 또는 디스크의 파일에서 마스터 키를 가져오고, 암호화된 테이블이 생성될 때마다 해당 테이블을 위한 임의의 테이블스페이스
      키를 발급한다.
    - 마스터 키를 이용해 테이블스페이스 키를 암호화해서 각 테이블의 데이터 파일 헤더에 저장한다.
    - 이렇게 생성된 테이블스페이스 키는 테이블이 삭제되지 않는 이상 절대 변경되지 않는다.
    - 테이블스페이스 키는 MySQL 서버 외부로 노출되지 않기 때문에 주기적으로 변경하지 않아도 보안상 취약점이 되지 않는다.
    - 하지만 **마스터 키는 외부의 파일을 이용하기 때문에 노출될 가능성이 있으므로 주기적인 변경이 필요하다.**

    ```sql
    ALTER INSTANCE ROTATE INNODB MASTER KEY;
    ```

    - 마스터 키를 변경하면 MySQL 서버는 기존의 마스터 키를 이용해 각 테이블의 테이블스페이스 키를 복호화한 다음 새로운 마스터 키로 다시 암호화한다.
    - 마스터 키가 변경되는 동안 MySQL 서버의 테이블스페이스 키 자체와 데이터 파일의 데이터는 전혀 변경되지 않는다.
    - **2단계 암호화 방식을 사용하는 이유는 키 변경으로 인한 과도한 시스템 부하를 피하기 위해서이다.**  
      (만약 테이블스페이스 키가 변경된다면 MySQL 서버는 데이터 파일의 모든 데이터를 다시 복호화했다가 암호화해야 한다.)

- TDE에서 지원되는 암호화 알고리즘은 AES 256 비트이며, 이외의 알고리즘은 지원되지 않는다.

### 암호화와 성능

- TDE 방식의 암호화를 사용하면 디스크로부터 한 번 읽은 데이터 페이지는 복호화되어 InnoDB의 버퍼 풀에 적재되고, **메모리에 적재되면 암호화되지 않은 테이블과 동일한 성능을 보인다.**
- InnoDB 버퍼풀에 존재하지 않는 데이터 페이지를 읽어야 하는 경우에는 복호화 과정을 거치기 때문에 복호화 시간 동안 쿼리 처리가 지연된다.
- 또한, 암호화된 테이블이 변경되면 디스크로 동기화될 때 암호화되어야 하기 때문에 추가로 시간이 더 걸린다.
- 하지만 **데이터 페이지 저장은 사용자의 쿼리를 처리하는 스레드가 아닌 MySQL 서버의 백그라운드 스레드가 수행하기 때문에 실제 사용자 쿼리가 지연되는 것은 아니다.**
- 일반적으로 데이터 페이지가 암호화 키보다 훨씬 크기 때문에 AES 암호화 알고리즘을 사용하더라도 암호화 결과와 평문의 크기가 동일하다.  
  ➡️ **암호화 한다고 해서 InnoDB 버퍼 풀의 효율이 달라지거나 메모리 사용 효율이 떨어지는 현상은 발생하지 않는다.**

#### 암호화와 압축

- 같은 테이블에 대해 암호화와 압축이 동시에 적용되면 MySQL 서버는 압축을 먼저 실행하고 암호화를 적용한다.
    - 암호화된 결과문은 랜덤한 바이트 배열을 가지게 되는데, 이는 압축률을 상당히 떨어뜨린다.
    - 압축된 데이터 페이지는 모든 상태(압축, 압축 해제)로 InnoDB 버퍼 풀에 존재할 수 있지만, 암호화된 테이블의 데이터 페이지는 복호화된 상태로만 버퍼 풀에 존재할 수 있다.

#### 성능 측정

- 디스크에 읽고 쓰는데 걸리는 평균 시간을 비교해보면, 암호화된 테이블은 암호화 되지 않은 테이블에 비해 읽기의 경우 3~5배, 쓰기의 경우 5~6배 느리다.

```sql
-- 암호화된 테이블의 일고 쓰기 성능 조회
SELECT (SUM(SUM_TIMER_READ) / SUM(COUNT_READ)) / 1000000000 AS avg_read_latency_ms,
       (SUM(SUM_TIMER_WRITE) / SUM(COUNT_WRITE)) / 1000000000 AS avg_write_latency_ms
FROM performance_schema.file_summary_by_instance
WHERE file_name LIKE '%DB_NAME/TABLE_NAME%';
```

### 암호화와 복제

- 마스터 키와 테이블스페이스 키는 레플리카 서버로 복제되지 않는다.
- 따라서 **소스 서버와 레플리카 서버는 서로 각자의 마스터 키와 테이블스페이스 키를 관리해야 한다.**
- 그래서 소스 서버와 레플리카 서버의 암호화 전 데이터 파일이 동일하더라도 실제 암호화된 데이터 파일의 내용은 완전히 달라진다.

#### 마스터 키 변경
- 소스 서버의 마스터 키를 변경할 때, 명령어 자체는 레플리카 서버로 복제되지만 실제 소스 서버의 마스터 키가 레플리카 서버로 전달되는 것은 아니다.
- 마스터 키 로테이션 명령을 실행하면 소스 서버와 레플리카 서버가 각각 서로 다른 마스터 키를 새로 발급받는다.
- 또한, **MySQL 서버를 백업 할 때 TDE의 키링을 백업하지 않으면 데이터를 복구할 수 없게 된다.**
- 보안을 위해 키링 파일을 데이터 파일과 별도로 보관하는 것을 권장하지만, 마스터 키가 주기적으로 변경될 수 있기 때문에 데이터 복구를 감안해서 결정해야 한다.

## 2. keyring_file 플러그인 설치

## 3. 테이블 암호화

## 4. 언두 로그 및 리두 로그 암호화

## 5. 바이너리 로그 암호화