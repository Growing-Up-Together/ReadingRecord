# 10. 실행 계획

## 1. 통계 정보

- MySQL 서버의 실행 계획에 가장 큰 영향을 미치는 것은 통계 정보이다.
- MySQL 5.7 버전까지는 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행 계획을 수립했다.

  → 하지만 실제 테이블 컬럼의 값들이 어떻게 분포되어 있는지 정보가 없어 실행 계획의 정확도가 떨어졌다.

- MySQL 8.0 버전부터는 **인덱스되지 않은 컬럼들에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입되었다.**

### 1.1 테이블 및 인덱스 통계 정보

- 비용 기반 최적화에서 가장 중요한 것은 통계 정보다.
- 통계 정보가 정확하지 않다면 전혀 엉뚱한 방향으로 쿼리를 실행할 수 있기 때문이다.

**MySQL 서버의 통계 정보 (MySQL 5.6~)**

- MySQL 5.5 버전까지는 각 테이블의 통계 정보가 메모리에만 관리되고, `SHOW INDEX` 명령으로만 테이블의 인덱스 컬럼의 분포도를 볼 수 있었다.
- MySQL 5.6 버전부터 각 테이블의 통계 정보를 mysql 데이터베이스의 `innodb_index_stats` 테이블과 `innodb_table_stats` 테이블로 관리할 수 있게 되었다.

    ```sql
    SHOW TABLES LIKE '%_stats';
    
    +---------------------------+
    | Tables_in_mysql (%_stats) |
    +---------------------------+
    | innodb_index_stats        |
    | innodb_table_stats        |
    +---------------------------+
    ```

- 테이블을 생성할 때 `STATS_PERSISTENT` 옵션을 사용하면 통계 정보를 영구적으로 보관할지 설정할 수 있다.

    ```sql
    CREATE TABLE tab_persistent (fd1 INT PRIMARY KEY, fd2 INT)
    ENGINE=InnoDB
    STATS_PERSISTENT=1;
    
    CREATE TABLE tab_trasient (fd1 INT PRIMARY KEY, fd2 INT)
    ENGINE=InnoDB
    STATS_PERSISTENT=0;
    ```

    - `STATS_PERSISTENT=0` : 테이블의 통계 정보를 MySQL 5.5 이전 버전의 방식으로 관리하며, `innodb_index_stats`와 `innodb_table_stats` 테이블에 저장하지 않음
    - `STATS_PERSISTENT=1` : 테이블의 통계 정보를 `innodb_index_stats`와 `innodb_table_stats` 테이블에 저장함
    - `STATS_PERSISTENT=DEFAULT` : 테이블을 생성할 때 별도의 `STATS_PERSISTENT` 옵션을 설정하지 않은 것과 동일하며, 테이블 통계를 영구적으로 관리할지는 `innodb_stats_persistent` 시스템 변수의 값으로 결정한다.
    - `innodb_stats_persistent` 시스템 변수의 기본 값은 `1`이다.

    ```sql
    SELECT * FROM mysql.innodb_table_stats
    WHERE table_name IN ('tab_persistent', 'tab_trasient') \G
  
    *************************** 1. row ***************************
               database_name: testdb
                  table_name: tab_persistent
                 last_update: 2022-10-14 21:06:39
                      n_rows: 0
        clustered_index_size: 1
    sum_of_other_index_sizes: 0
    1 row in set (0.03 sec)
    ```

- 통계 정보의 각 컬럼은 다음과 같은 값을 저장하고 있다.
    - innodb_index_stats
        - `stat_name='d_diff_pfx%'` : 인덱스가 가진 유니크한 값의 개수
        - `stat_name='n_leaf_pages'` : 인덱스의 리프 노트 페이지 개수
        - `stat_name='size'` : 인덱스 트리의 전체 페이지 개수
    - innodb_table_status
        - `n_rows` : 테이블의 전체 레코드 건수
        - `clustered_index_size` : 프라이머리 키의 크기 (InnoDB 페이지 개수)
        - `sum_of_other_index_sizes` : 프라이머리 키를 제외한 인덱스의 크기 (InnoDB 페이지 개수)

    ```sql
    ALTER TABLE testdb.employees STATS_PERSISTENT=1;
    
    SELECT * 
    FROM mysql.innodb_index_stats
    WHERE database_name = 'testdb' AND table_name = 'employees';
  
    +---------------+------------+---------------------+---------------------+--------------+------------+-------------+-----------------------------------+
    | database_name | table_name | index_name          | last_update         | stat_name    | stat_value | sample_size | stat_description                  |
    +---------------+------------+---------------------+---------------------+--------------+------------+-------------+-----------------------------------+
    | testdb        | employees  | PRIMARY             | 2022-10-14 21:17:31 | n_diff_pfx01 |     299335 |          20 | emp_no                            |
    | testdb        | employees  | PRIMARY             | 2022-10-14 21:17:31 | n_leaf_pages |        886 |        NULL | Number of leaf pages in the index |
    | testdb        | employees  | PRIMARY             | 2022-10-14 21:17:31 | size         |        929 |        NULL | Number of pages in the index      |
    | testdb        | employees  | ix_firstname        | 2022-10-14 21:17:31 | n_diff_pfx01 |       1304 |          20 | first_name                        |
    | testdb        | employees  | ix_firstname        | 2022-10-14 21:17:31 | n_diff_pfx02 |     329443 |          20 | first_name,emp_no                 |
    | testdb        | employees  | ix_firstname        | 2022-10-14 21:17:31 | n_leaf_pages |        496 |        NULL | Number of leaf pages in the index |
    | testdb        | employees  | ix_firstname        | 2022-10-14 21:17:31 | size         |        609 |        NULL | Number of pages in the index      |
    | testdb        | employees  | ix_gender_birthdate | 2022-10-14 21:17:31 | n_diff_pfx01 |          1 |           3 | gender                            |
    | testdb        | employees  | ix_gender_birthdate | 2022-10-14 21:17:31 | n_diff_pfx02 |       9061 |          20 | gender,birth_date                 |
    | testdb        | employees  | ix_gender_birthdate | 2022-10-14 21:17:31 | n_diff_pfx03 |     309467 |          20 | gender,birth_date,emp_no          |
    | testdb        | employees  | ix_gender_birthdate | 2022-10-14 21:17:31 | n_leaf_pages |        361 |        NULL | Number of leaf pages in the index |
    | testdb        | employees  | ix_gender_birthdate | 2022-10-14 21:17:31 | size         |        417 |        NULL | Number of pages in the index      |
    | testdb        | employees  | ix_hiredate         | 2022-10-14 21:17:31 | n_diff_pfx01 |       4468 |          20 | hire_date                         |
    | testdb        | employees  | ix_hiredate         | 2022-10-14 21:17:31 | n_diff_pfx02 |     296778 |          20 | hire_date,emp_no                  |
    | testdb        | employees  | ix_hiredate         | 2022-10-14 21:17:31 | n_leaf_pages |        294 |        NULL | Number of leaf pages in the index |
    | testdb        | employees  | ix_hiredate         | 2022-10-14 21:17:31 | size         |        353 |        NULL | Number of pages in the index      |
    +---------------+------------+---------------------+---------------------+--------------+------------+-------------+-----------------------------------+
    
    SELECT *
    FROM mysql.innodb_table_stats
    WHERE database_name = 'testdb' AND table_name = 'employees';
  
    +---------------+------------+---------------------+--------+----------------------+--------------------------+
    | database_name | table_name | last_update         | n_rows | clustered_index_size | sum_of_other_index_sizes |
    +---------------+------------+---------------------+--------+----------------------+--------------------------+
    | testdb        | employees  | 2022-10-14 21:17:31 | 299335 |                  929 |                     1379 |
    +---------------+------------+---------------------+--------+----------------------+--------------------------+
    ```
    - innodb_table_stats.sum_of_other_index_size 컬럼의 값은 테이블의 `STATS_AUTO_RECALC` 옵션에 따라 `0`으로 보일 수도 있는데, `ANALYZE TABLE` 명령을 실행하면 통계값이 저장된다.

**통계 정보가 자동으로 갱신되는 이벤트**

- 테이블이 새로 오픈되는 경우
- 테이블의 레코드가 대량으로 변경되는 경우 (테이블의 전체 레코드 중에서 1/16 정도의 UPDATE 또는 INSER나 DELETE 가 실행되는 경우)
- ANALYZE TABLE 명령이 실행되는 경우
- SHOW TABLE STATUS 명령이나 SHOW INDEX FROM 명령이 실행되는 경우
- InnoDB 모니터가 활성화되는 경우
- innodb_stats_on_metadata 시스템 설정이 ON인 상태에서 SHOW TABLE STATUS 명령이 실행되는 경우
→ 테이블의 통계 정보가 자주 갱신되면 응용 프로그램의 쿼리를 레인지 스캔으로 실행하다가 풀 스캔으로 실행하는 상황이 발생할 수도 있다.
- `innodb_stats_auto_recalc` 시스템 변수의 값을 `OFF`로 설정하면 통계 정보가 자동으로 갱신되는 것을 막을 수 있다.

**통계 정보 수집을 위한 샘플링**

- MySQL 5.6 버전에서 테이블의 통계 정보를 수집할 때 몇 개의 InnoDB 테이블 블록을 샘플링할지 결정하는 옵션에는 두 가지가 있다.
    - `innodb_stats_transient_sample_pages` (기본 값 8)  
      자동으로 통계 정보 수집이 실행될 때 몇 개의 페이지를 샘플링해서 분석할지 설정
    - `innodb_stats_persistent_sample_pages` (기본 값 20)  
      ANALYZE TABLE 명령이 실행될 때 몇 개의 페이지를 샘플링해서 분석할지 설정

- 통계 정보의 정확성에 의해 쿼리의 성능이 결정되기 때문에 통계 정보의 정확성을 높이는데 시간을 투자할 가치가 충분하다.
    - 영구적인 통계 정보를 사용한다면 MySQL 서버의 점검이나 사용량이 많지 않은 시간을 이용해서 `innodb_stats_persistent_sample_pages` 값을 조정하여 더 정확한 통계 정보를 수집할 수 있다.
    - 하지만 이 값을 너무 높이면 통계 정보 수집 시간이 길어지므로 주의해야 한다.

### 1.2 히스토그램

- MySQL 8.0 버전부터 컬럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보를 활용할 수 있게 되었다.

**히스토그램 정보 수집**

- 히스토그램 정보는 컬럼 단위로 관리된다.
- 히스토그램은 자동으로 수집되지 않으므로 수동으로 명령어를 실행하여 수집해야 한다.

    ```sql
    ALTER TABLE {talbe_name} UPDATE HISTOGRAM;
    ```

- 수집된 히스토그램 정보는 시스템 딕셔너리에 저장되고, MySQL 서버가 시작될 때 딕셔너리의 히스토그램 정보를 `information_schema.column_statistics` 테이블로 로드한다.
    - 암호화된 테이블에서는 히스토그램을 수집할 수 없다. (Cannot create histogram statistics for an encrypted table)

    ```sql
    -- // 히스토그램 정보 수집
    ANALYZE TABLE testdb.employees
    UPDATE HISTOGRAM ON gender, hire_date;
  
    +------------------+-----------+----------+------------------------------------------------------+
    | Table            | Op        | Msg_type | Msg_text                                             |
    +------------------+-----------+----------+------------------------------------------------------+
    | testdb.employees | histogram | status   | Histogram statistics created for column 'gender'.    |
    | testdb.employees | histogram | status   | Histogram statistics created for column 'hire_date'. |
    +------------------+-----------+----------+------------------------------------------------------+
    
    -- // 히스토그램 정보 조회
    SELECT *
    FROM information_schema.column_statistics
    WHERE schema_name = 'testdb' AND table_name = 'employees' \G
  
    *************************** 1. row ***************************
    SCHEMA_NAME: testdb
     TABLE_NAME: employees
    COLUMN_NAME: gender
      HISTOGRAM: {"buckets": [[1, 0.6022134473264744], [2, 1.0]], "data-type": "enum", "null-values": 0.0, "collation-id": 45, "last-updated": "2022-10-18 14:48:18.023937", "sampling-rate": 0.3464196832892688, "histogram-type": "singleton", "number-of-buckets-specified": 100}
    *************************** 2. row ***************************
    SCHEMA_NAME: testdb
     TABLE_NAME: employees
    COLUMN_NAME: hire_date
      HISTOGRAM: {"buckets": [
                                ["1985-02-01", "1985-02-28", 0.009898927691638892, 28], 
                                ["1985-03-01", "1985-03-28", 0.020069555136936677, 28], 
                                ["1985-03-29", "1985-04-25", 0.0301405593392262, 28], 
                                ["1985-04-26", "1985-05-24", 0.04006665700623098, 29], 
                                ["1985-05-25", "1985-06-20", 0.05003803796551225, 27], 
                                ...
                                ["1998-08-07", "2000-01-28", 1.0, 467]
                             ], 
    "data-type": "date", 
    "null-values": 0.0, 
    "collation-id": 8, 
    "last-updated": "2022-10-18 14:48:18.033156", 
    "sampling-rate": 0.3464196832892688, 
    "histogram-type": "equi-height", 
    "number-of-buckets-specified": 100
    }
    ```

    - `sampling-rate`
        - 히스토그램 정보를 수집하기 위해 스캔한 페이지의 비율을 저장한다.
        - 샘플링 비율이 0.35라면 전체 데이터 페이지의 35%를 스캔해서 정보를 수집했다는 것을 의미한다.
        - MySQL 8.0.19 미만의 버전까지는 `histogram_generation_max_mem_size`  시스템 변수로 히스토그램 생성 시 샘플링 비율을 설정할 수 있다.
        - MySQL 8.0.19 버전부터는 InnoDB 스토리지 엔진이 자체적으로 샘플링 알고리즘을 구현하여, 히스토그램 수집 시 풀 테이블 스캔이 발생하지 않는다.
    - `histogram-type`
        - 히스토그램의 종류를 저장한다.
    - `number-of-buchkets-specified`
        - 히스토그램을 생성할 때 설정했던 버킷의 개수를 저장한다.
        - 별도로 설정하지 않으면 기본 100개의 버킷이 사용되며, 최대 1024개를 설정할 수 있다.

**히스토그램의 종류**

- 히스토그램은 버킷(Bucket) 단위로 구분되어 레코드 건수나 컬럼값의 범위를 관리한다.
1. **Singleton (싱글톤 히스토그램)**  
   컬럼값 개별로 레코드 건수를 관리하는 히스토그램  
   → 싱글톤 히스토그램은 주로 코드 값과 같이 유니크한 값의 개수가 상대적으로 적은(히스토그램의 버킷 수보다 적은) 경우 사용된다.

2. **Equi-Height (높이 균형 히스토그램)**  
   컬럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램  
   → 높이 균형 히스토그램은 컬럼의 범위에 대한 레코드 건수 비율이 누적되므로, 그래프 상으로 그래프 기울기를 의미한다.

**히스토그램의 삭제**

- 히스토그램의 삭제 작업은 테이블의 데이터를 참조하는 것이 아니라 딕셔너리의 내용만 삭제하기 때문에 다른 쿼리 처리의 성능에 영향을 주지 않고 즉시 완료된다.

    ```sql
    ANALYZE TABLE testdb.employees
    DROP HISTOGRAM ON gender, hire_date;
  
    +------------------+-----------+----------+-------------------------------------------------------+
    | Table            | Op        | Msg_type | Msg_text                                              |
    +------------------+-----------+----------+-------------------------------------------------------+
    | testdb.employees | histogram | Error    | No histogram statistics found for column 'gender'.    |
    | testdb.employees | histogram | Error    | No histogram statistics found for column 'hire_date'. |
    +------------------+-----------+----------+-------------------------------------------------------+
    ```

- 히스토그램을 삭제하지 않고 MySQL 옵티마이저가 히스토그램을 사용하지 않게 하려면 optimizer_switch 시스템 변수의 값을 변경하면 된다.

    ```sql
    SET GLOBAL optimizer_switch = 'condition_fanout_filter=off';
    
    -- // 현재 커넥션에서 실행되는 쿼리만 히스토그램을 사용하지 않게 설정
    SET SESSION optimizer_switch = 'condition_fanout_filter=off';
    
    -- // 현재 쿼리만 히스토그램을 사용하지 않게 설정
    SELECT /*+ SET_VAR(optimizer_switch = 'condition_fanout_filter=off') */ *
    FROM employees;
    ```

**히스토그램의 용도**

- 실제 응용 프로그램의 데이터는 항상 균등한 분포도를 가지지 않는다.
- 히스토그램은 특정 컬럼이 가지는 모든 값에 대한 분포도 정보를 가지지 않지만, 각 범위(버킷)별로 레코드의 건수와 유니크한 값의 개수 정보를 가지기 때문에 훨씬 정확한 예측을 할 수 있다.

    ```sql
    -- // 히스토그램을 사용하지 않고 조회
    EXPLAIN
    SELECT *
    FROM employees
    WHERE first_name = 'Zita'
      AND birth_date BETWEEN '1950-01-01' AND '1960-01-01';
  
    +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    | id | select_type | table     | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra       |
    +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    |  1 | SIMPLE      | employees | NULL       | ref  | ix_firstname  | ix_firstname | 58      | const |  224 |    11.11 | Using where |
    +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    
    -- // 히스토그램을 사용
    ANALYZE TABLE employees
      UPDATE HISTOGRAM ON first_name, birth_date;
  
    +------------------+-----------+----------+-------------------------------------------------------+
    | Table            | Op        | Msg_type | Msg_text                                              |
    +------------------+-----------+----------+-------------------------------------------------------+
    | testdb.employees | histogram | status   | Histogram statistics created for column 'birth_date'. |
    | testdb.employees | histogram | status   | Histogram statistics created for column 'first_name'. |
    +------------------+-----------+----------+-------------------------------------------------------+
    
    -- // 위의 SELECT 쿼리 재조회
  
    +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    | id | select_type | table     | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra       |
    +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    |  1 | SIMPLE      | employees | NULL       | ref  | ix_firstname  | ix_firstname | 58      | const |  224 |    60.61 | Using where |
    +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    ```

  → 단순 통계 정보만 이용한 경우와 히스토크램을 이용한 경우의 차이가 매우 큰 것을 알 수 있다.

    ```sql
    SELECT
    SUM(
        CASE WHEN birth_date BETWEEN '1950-01-01' AND '1960-01-01' 
             THEN 1 
             ELSE 0 END
       ) / COUNT(*) AS ratio
    FROM employees 
    WHERE first_name = 'Zita';
    +--------+
    | ratio  |
    +--------+
    | 0.6384 |
    +--------+
    ```

    - 히스토그램 정보가 없으면 옵티마이저는 데이터가 균등하게 분포되어 있을 것으로 예측한다. 하지만 히스토그램이 있으면 특정 범위의 데이터가 많고 적음을 식별할 수 있다.
    - 조인의 경우에도, 히스토그램 정보가 있으면 어느 테이블을 먼저 읽어야 조인 횟수를 줄일 수 있을지 옵티마이저가 더 정확히 판단할 수 있다.

**히스토그램과 인덱스**

- 히스토그램과 인덱스는 완전히 다른 객체이기 때문에 서로 비교할 대상은 아니지만, MySQL 서버에서 인덱스는 부족한 통계 정보를 수집하기 위해 사용된다는 측면에서는 어느 정도 공통점을 가진다.
- MySQL 서버에서는 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택한다.
- **이때, 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링해서 살펴보는데, 이 작업을 인덱스 다이브(Index Dive)라고 표현한다.**
- MySQL 8.0 버전에서는 인덱스된 컬럼을 검색 조건으로 사용하는 경우, 그 컬럼의 히스토그램은 사용하지 않고 실제 인덱스 다이브를 통해 직접 수집한 정보를 활용한다.
- MySQL 8.0 버전에서 히스토그램은 주로 인덱스되지 않은 컬럼에 대한 데이터 분포를 참조하는 용도로 사용된다.
- 하지만 인덱스 다이브 작업은 어느 정도의 비용이 필요하며, 때로는 (IN 절에 많은 값을 검색하는 경우) 실행 계획 수립만으로도 상당한 인덱스 다이브를 실행하고 비용도 그만큼 커진다.

### 1.3 코스트 모델(Cost Model)

- MySQL 서버가 쿼리를 처리하기 위한 작업
    - 디스크로부터 데이터 페이지 읽기
    - 메모리(InnoDB 버퍼 풀)로부터 데이터 페이지 읽기
    - 인덱스 키 비교
    - 레코드 평가
    - 메모리 임시 테이블 작업
    - 디스크 임시 테이블 작업
- 전체 쿼리의 비용을 계산하는데 필요한 단위 작업들의 비용을 코스트 모델이라고 한다.
- 코스트 모델의 설정 테이블
    - `server_cost` : 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
    - `engine_cost` : 레코드를 가진 데이터 페이지를 가져오는데 필요한 비용 관리
- MySQL 8.0 버전의 코스트 모델에서 지원하는 단위 작업

    | type | cost_name | deafult_value | 설명 |
    | :---: | :--- | :---: | :--- |
    | engine_cost | io_block_read_cost | 1.00 | 디스크 데이터 페이지 읽기 |
    |  | memory_block_read_cost | 0.25 | 메모리 데이터 페이지 읽기 |
    | server_cost | disk_temptable_create_cost | 20.00 | 디스크 임시 테이블 생성 |
    |  | disk_temptable_row_cost | 0.50 | 디스크 임시 테이블의 레코드 읽기 |
    |  | key_compare_cost | 0.05 | 인덱스 비교 |
    |  | memory_temptable_create_cost | 1.00 | 메모리 임시 테이블 생성 |
    |  | memory_temptable_row_cost | 0.10 | 메모리 임시 테이블의 레코드 읽기 |
    |  | row_evaluate_cost | 0.10 | 레코드 비교 |

    - 단위 작업의 비용이 변경될 때 예상할 수 있는 결과
        - `key_compare_cost` 비용을 높이면 MySQL 서버 옵티마이저가 가능하면 정렬을 수행하지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.
        - `row_evaluate_cost` 비용을 높이면 풀 스캔을 실행하는 쿼리들의 비용이 높아지고, 인덱스 레인지 스캔을 사용하는 실행 계획을 선택할 가능성이 높아진다.
        - `disk_temptable_create_cost`와 `disk_temptable_row_cost` 비용을 높이면, 디스크에 임시 테이블을 만들지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.
        - `memory_temptable_create_cost`와 `memory_temptable_row_cost` 비용을 높이면, 메모리 임시 테이블을 만들지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.
        - `io_block_read_cost` 비용이 높아지면, InnoDB 버퍼 풀에 데이터 페이지가 많이 적재되어 있는 인덱스를 사용하는 실행 계획을 선택할 가능성이 높아진다.
        - `memory_block_read_cost` 비용이 높아지면, InnoDB 버퍼 풀에 적재된 데이터 페이지가 상대적으로 적다고 하더라도 그 인덱스를 사용할 가능성이 높아진다.
- 각 실행 계획의 계산된 비용(Cost) 확인

    ```sql
    -- // TREE 포맷 조회
    EXPLAIN FORMAT = TREE
    SELECT *
    FROM employees WHERE first_name = 'Matt' \G
    
    *************************** 1. row ***************************
    EXPLAIN: -> Index lookup on employees using ix_firstname (first_name='Matt')  (cost=147.01 rows=233)
    
    -- // JSON 포맷 조회
    EXPLAIN FORMAT = JSON
    SELECT *
    FROM employees WHERE first_name = 'Matt' \G
    
    *************************** 1. row ***************************
    EXPLAIN: {
      "query_block": {
        "select_id": 1,
        "cost_info": {
          "query_cost": "147.01"
        },
        "table": {
          "table_name": "employees",
          "access_type": "ref",
          "possible_keys": [
            "ix_firstname"
          ],
          "key": "ix_firstname",
          "used_key_parts": [
            "first_name"
          ],
          "key_length": "58",
          "ref": [
            "const"
          ],
          "rows_examined_per_scan": 233,
          "rows_produced_per_join": 233,
          "filtered": "100.00",
          "cost_info": {
            "read_cost": "123.71",
            "eval_cost": "23.30",
            "prefix_cost": "147.01",
            "data_read_per_join": "30K"
          },
          "used_columns": [
            "emp_no",
            "birth_date",
            "first_name",
            "last_name",
            "gender",
            "hire_date"
          ]
        }
      }
    }
    ```

  **→ 코스트 모델에서 중요한 것은 각 단위 작업에 설정되는 값에 따라 실행 계획의 비용을 파악하는 것이다.**

