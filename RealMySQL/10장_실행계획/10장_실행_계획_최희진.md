# 10. 실행 계획

## 1. 통계 정보

- MySQL 서버의 실행 계획에 가장 큰 영향을 미치는 것은 통계 정보이다.
- MySQL 5.7 버전까지는 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행 계획을 수립했다.

  → 하지만 실제 테이블 칼럼의 값들이 어떻게 분포되어 있는지 정보가 없어 실행 계획의 정확도가 떨어졌다.

- MySQL 8.0 버전부터는 **인덱스되지 않은 칼럼들에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입되었다.**

### 1.1 테이블 및 인덱스 통계 정보

- 비용 기반 최적화에서 가장 중요한 것은 통계 정보다.
- 통계 정보가 정확하지 않다면 전혀 엉뚱한 방향으로 쿼리를 실행할 수 있기 때문이다.

**MySQL 서버의 통계 정보 (MySQL 5.6~)**

- MySQL 5.5 버전까지는 각 테이블의 통계 정보가 메모리에만 관리되고, `SHOW INDEX` 명령으로만 테이블의 인덱스 칼럼의 분포도를 볼 수 있었다.
- MySQL 5.6 버전부터 각 테이블의 통계 정보를 mysql 데이터베이스의 `innodb_index_stats` 테이블과 `innodb_table_stats` 테이블로 관리할 수 있게 되었다.

    ```sql
    SHOW TABLES LIKE '%_stats';
    
    +---------------------------+
    | Tables_in_mysql (%_stats) |
    +---------------------------+
    | innodb_index_stats        |
    | innodb_table_stats        |
    +---------------------------+
    ```

- 테이블을 생성할 때 `STATS_PERSISTENT` 옵션을 사용하면 통계 정보를 영구적으로 보관할지 설정할 수 있다.

    ```sql
    CREATE TABLE tab_persistent (fd1 INT PRIMARY KEY, fd2 INT)
    ENGINE=InnoDB
    STATS_PERSISTENT=1;
    
    CREATE TABLE tab_trasient (fd1 INT PRIMARY KEY, fd2 INT)
    ENGINE=InnoDB
    STATS_PERSISTENT=0;
    ```

    - `STATS_PERSISTENT=0` : 테이블의 통계 정보를 MySQL 5.5 이전 버전의 방식으로 관리하며, `innodb_index_stats`와 `innodb_table_stats` 테이블에 저장하지 않음
    - `STATS_PERSISTENT=1` : 테이블의 통계 정보를 `innodb_index_stats`와 `innodb_table_stats` 테이블에 저장함
    - `STATS_PERSISTENT=DEFAULT` : 테이블을 생성할 때 별도의 `STATS_PERSISTENT` 옵션을 설정하지 않은 것과 동일하며, 테이블 통계를 영구적으로 관리할지는 `innodb_stats_persistent` 시스템 변수의 값으로 결정한다.
    - `innodb_stats_persistent` 시스템 변수의 기본 값은 `1`이다.
    
      ```sql
      SELECT * FROM mysql.innodb_table_stats
      WHERE table_name IN ('tab_persistent', 'tab_trasient') \G
    
      *************************** 1. row ***************************
                 database_name: testdb
                    table_name: tab_persistent
                   last_update: 2022-10-14 21:06:39
                        n_rows: 0
          clustered_index_size: 1
      sum_of_other_index_sizes: 0
      1 row in set (0.03 sec)
      ```

- 통계 정보의 각 칼럼은 다음과 같은 값을 저장하고 있다.
    - innodb_index_stats
        - `stat_name='d_diff_pfx%'` : 인덱스가 가진 유니크한 값의 개수
        - `stat_name='n_leaf_pages'` : 인덱스의 리프 노트 페이지 개수
        - `stat_name='size'` : 인덱스 트리의 전체 페이지 개수
    - innodb_table_status
        - `n_rows` : 테이블의 전체 레코드 건수
        - `clustered_index_size` : 프라이머리 키의 크기 (InnoDB 페이지 개수)
        - `sum_of_other_index_sizes` : 프라이머리 키를 제외한 인덱스의 크기 (InnoDB 페이지 개수)

    ```sql
    ALTER TABLE testdb.employees STATS_PERSISTENT=1;
    
    SELECT * 
    FROM mysql.innodb_index_stats
    WHERE database_name = 'testdb' AND table_name = 'employees';
  
    +---------------+------------+---------------------+---------------------+--------------+------------+-------------+-----------------------------------+
    | database_name | table_name | index_name          | last_update         | stat_name    | stat_value | sample_size | stat_description                  |
    +---------------+------------+---------------------+---------------------+--------------+------------+-------------+-----------------------------------+
    | testdb        | employees  | PRIMARY             | 2022-10-14 21:17:31 | n_diff_pfx01 |     299335 |          20 | emp_no                            |
    | testdb        | employees  | PRIMARY             | 2022-10-14 21:17:31 | n_leaf_pages |        886 |        NULL | Number of leaf pages in the index |
    | testdb        | employees  | PRIMARY             | 2022-10-14 21:17:31 | size         |        929 |        NULL | Number of pages in the index      |
    | testdb        | employees  | ix_firstname        | 2022-10-14 21:17:31 | n_diff_pfx01 |       1304 |          20 | first_name                        |
    | testdb        | employees  | ix_firstname        | 2022-10-14 21:17:31 | n_diff_pfx02 |     329443 |          20 | first_name,emp_no                 |
    | testdb        | employees  | ix_firstname        | 2022-10-14 21:17:31 | n_leaf_pages |        496 |        NULL | Number of leaf pages in the index |
    | testdb        | employees  | ix_firstname        | 2022-10-14 21:17:31 | size         |        609 |        NULL | Number of pages in the index      |
    | testdb        | employees  | ix_gender_birthdate | 2022-10-14 21:17:31 | n_diff_pfx01 |          1 |           3 | gender                            |
    | testdb        | employees  | ix_gender_birthdate | 2022-10-14 21:17:31 | n_diff_pfx02 |       9061 |          20 | gender,birth_date                 |
    | testdb        | employees  | ix_gender_birthdate | 2022-10-14 21:17:31 | n_diff_pfx03 |     309467 |          20 | gender,birth_date,emp_no          |
    | testdb        | employees  | ix_gender_birthdate | 2022-10-14 21:17:31 | n_leaf_pages |        361 |        NULL | Number of leaf pages in the index |
    | testdb        | employees  | ix_gender_birthdate | 2022-10-14 21:17:31 | size         |        417 |        NULL | Number of pages in the index      |
    | testdb        | employees  | ix_hiredate         | 2022-10-14 21:17:31 | n_diff_pfx01 |       4468 |          20 | hire_date                         |
    | testdb        | employees  | ix_hiredate         | 2022-10-14 21:17:31 | n_diff_pfx02 |     296778 |          20 | hire_date,emp_no                  |
    | testdb        | employees  | ix_hiredate         | 2022-10-14 21:17:31 | n_leaf_pages |        294 |        NULL | Number of leaf pages in the index |
    | testdb        | employees  | ix_hiredate         | 2022-10-14 21:17:31 | size         |        353 |        NULL | Number of pages in the index      |
    +---------------+------------+---------------------+---------------------+--------------+------------+-------------+-----------------------------------+
    
    SELECT *
    FROM mysql.innodb_table_stats
    WHERE database_name = 'testdb' AND table_name = 'employees';
  
    +---------------+------------+---------------------+--------+----------------------+--------------------------+
    | database_name | table_name | last_update         | n_rows | clustered_index_size | sum_of_other_index_sizes |
    +---------------+------------+---------------------+--------+----------------------+--------------------------+
    | testdb        | employees  | 2022-10-14 21:17:31 | 299335 |                  929 |                     1379 |
    +---------------+------------+---------------------+--------+----------------------+--------------------------+
    ```
    - innodb_table_stats.sum_of_other_index_size 칼럼의 값은 테이블의 `STATS_AUTO_RECALC` 옵션에 따라 `0`으로 보일 수도 있는데, `ANALYZE TABLE` 명령을 실행하면 통계값이 저장된다.

**통계 정보가 자동으로 갱신되는 이벤트**

- 테이블이 새로 오픈되는 경우
- 테이블의 레코드가 대량으로 변경되는 경우 (테이블의 전체 레코드 중에서 1/16 정도의 UPDATE 또는 INSER나 DELETE 가 실행되는 경우)
- ANALYZE TABLE 명령이 실행되는 경우
- SHOW TABLE STATUS 명령이나 SHOW INDEX FROM 명령이 실행되는 경우
- InnoDB 모니터가 활성화되는 경우
- innodb_stats_on_metadata 시스템 설정이 ON인 상태에서 SHOW TABLE STATUS 명령이 실행되는 경우
→ 테이블의 통계 정보가 자주 갱신되면 응용 프로그램의 쿼리를 레인지 스캔으로 실행하다가 풀 스캔으로 실행하는 상황이 발생할 수도 있다.
- `innodb_stats_auto_recalc` 시스템 변수의 값을 `OFF`로 설정하면 통계 정보가 자동으로 갱신되는 것을 막을 수 있다.

**통계 정보 수집을 위한 샘플링**

- MySQL 5.6 버전에서 테이블의 통계 정보를 수집할 때 몇 개의 InnoDB 테이블 블록을 샘플링할지 결정하는 옵션에는 두 가지가 있다.
    - `innodb_stats_transient_sample_pages` (기본 값 8)  
      자동으로 통계 정보 수집이 실행될 때 몇 개의 페이지를 샘플링해서 분석할지 설정
    - `innodb_stats_persistent_sample_pages` (기본 값 20)  
      ANALYZE TABLE 명령이 실행될 때 몇 개의 페이지를 샘플링해서 분석할지 설정

- 통계 정보의 정확성에 의해 쿼리의 성능이 결정되기 때문에 통계 정보의 정확성을 높이는데 시간을 투자할 가치가 충분하다.
    - 영구적인 통계 정보를 사용한다면 MySQL 서버의 점검이나 사용량이 많지 않은 시간을 이용해서 `innodb_stats_persistent_sample_pages` 값을 조정하여 더 정확한 통계 정보를 수집할 수 있다.
    - 하지만 이 값을 너무 높이면 통계 정보 수집 시간이 길어지므로 주의해야 한다.

### 1.2 히스토그램

- MySQL 8.0 버전부터 칼럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보를 활용할 수 있게 되었다.

**히스토그램 정보 수집**

- 히스토그램 정보는 칼럼 단위로 관리된다.
- 히스토그램은 자동으로 수집되지 않으므로 수동으로 명령어를 실행하여 수집해야 한다.

    ```sql
    ALTER TABLE {talbe_name} UPDATE HISTOGRAM;
    ```

- 수집된 히스토그램 정보는 시스템 딕셔너리에 저장되고, MySQL 서버가 시작될 때 딕셔너리의 히스토그램 정보를 `information_schema.column_statistics` 테이블로 로드한다.
    - 암호화된 테이블에서는 히스토그램을 수집할 수 없다. (Cannot create histogram statistics for an encrypted table)

    ```sql
    -- // 히스토그램 정보 수집
    ANALYZE TABLE testdb.employees
    UPDATE HISTOGRAM ON gender, hire_date;
  
    +------------------+-----------+----------+------------------------------------------------------+
    | Table            | Op        | Msg_type | Msg_text                                             |
    +------------------+-----------+----------+------------------------------------------------------+
    | testdb.employees | histogram | status   | Histogram statistics created for column 'gender'.    |
    | testdb.employees | histogram | status   | Histogram statistics created for column 'hire_date'. |
    +------------------+-----------+----------+------------------------------------------------------+
    
    -- // 히스토그램 정보 조회
    SELECT *
    FROM information_schema.column_statistics
    WHERE schema_name = 'testdb' AND table_name = 'employees' \G
  
    *************************** 1. row ***************************
    SCHEMA_NAME: testdb
     TABLE_NAME: employees
    COLUMN_NAME: gender
      HISTOGRAM: {"buckets": [[1, 0.6022134473264744], [2, 1.0]], "data-type": "enum", "null-values": 0.0, "collation-id": 45, "last-updated": "2022-10-18 14:48:18.023937", "sampling-rate": 0.3464196832892688, "histogram-type": "singleton", "number-of-buckets-specified": 100}
    *************************** 2. row ***************************
    SCHEMA_NAME: testdb
     TABLE_NAME: employees
    COLUMN_NAME: hire_date
      HISTOGRAM: {"buckets": [
                                ["1985-02-01", "1985-02-28", 0.009898927691638892, 28], 
                                ["1985-03-01", "1985-03-28", 0.020069555136936677, 28], 
                                ["1985-03-29", "1985-04-25", 0.0301405593392262, 28], 
                                ["1985-04-26", "1985-05-24", 0.04006665700623098, 29], 
                                ["1985-05-25", "1985-06-20", 0.05003803796551225, 27], 
                                ...
                                ["1998-08-07", "2000-01-28", 1.0, 467]
                             ], 
    "data-type": "date", 
    "null-values": 0.0, 
    "collation-id": 8, 
    "last-updated": "2022-10-18 14:48:18.033156", 
    "sampling-rate": 0.3464196832892688, 
    "histogram-type": "equi-height", 
    "number-of-buckets-specified": 100
    }
    ```

    - `sampling-rate`
        - 히스토그램 정보를 수집하기 위해 스캔한 페이지의 비율을 저장한다.
        - 샘플링 비율이 0.35라면 전체 데이터 페이지의 35%를 스캔해서 정보를 수집했다는 것을 의미한다.
        - MySQL 8.0.19 미만의 버전까지는 `histogram_generation_max_mem_size`  시스템 변수로 히스토그램 생성 시 샘플링 비율을 설정할 수 있다.
        - MySQL 8.0.19 버전부터는 InnoDB 스토리지 엔진이 자체적으로 샘플링 알고리즘을 구현하여, 히스토그램 수집 시 풀 테이블 스캔이 발생하지 않는다.
    - `histogram-type`
        - 히스토그램의 종류를 저장한다.
    - `number-of-buchkets-specified`
        - 히스토그램을 생성할 때 설정했던 버킷의 개수를 저장한다.
        - 별도로 설정하지 않으면 기본 100개의 버킷이 사용되며, 최대 1024개를 설정할 수 있다.

**히스토그램의 종류**

- 히스토그램은 버킷(Bucket) 단위로 구분되어 레코드 건수나 칼럼값의 범위를 관리한다.
1. **Singleton (싱글톤 히스토그램)**  
   칼럼값 개별로 레코드 건수를 관리하는 히스토그램  
   → 싱글톤 히스토그램은 주로 코드 값과 같이 유니크한 값의 개수가 상대적으로 적은(히스토그램의 버킷 수보다 적은) 경우 사용된다.

2. **Equi-Height (높이 균형 히스토그램)**  
   칼럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램  
   → 높이 균형 히스토그램은 칼럼의 범위에 대한 레코드 건수 비율이 누적되므로, 그래프 상으로 그래프 기울기를 의미한다.

**히스토그램의 삭제**

- 히스토그램의 삭제 작업은 테이블의 데이터를 참조하는 것이 아니라 딕셔너리의 내용만 삭제하기 때문에 다른 쿼리 처리의 성능에 영향을 주지 않고 즉시 완료된다.

    ```sql
    ANALYZE TABLE testdb.employees
    DROP HISTOGRAM ON gender, hire_date;
  
    +------------------+-----------+----------+-------------------------------------------------------+
    | Table            | Op        | Msg_type | Msg_text                                              |
    +------------------+-----------+----------+-------------------------------------------------------+
    | testdb.employees | histogram | Error    | No histogram statistics found for column 'gender'.    |
    | testdb.employees | histogram | Error    | No histogram statistics found for column 'hire_date'. |
    +------------------+-----------+----------+-------------------------------------------------------+
    ```

- 히스토그램을 삭제하지 않고 MySQL 옵티마이저가 히스토그램을 사용하지 않게 하려면 optimizer_switch 시스템 변수의 값을 변경하면 된다.

    ```sql
    SET GLOBAL optimizer_switch = 'condition_fanout_filter=off';
    
    -- // 현재 커넥션에서 실행되는 쿼리만 히스토그램을 사용하지 않게 설정
    SET SESSION optimizer_switch = 'condition_fanout_filter=off';
    
    -- // 현재 쿼리만 히스토그램을 사용하지 않게 설정
    SELECT /*+ SET_VAR(optimizer_switch = 'condition_fanout_filter=off') */ *
    FROM employees;
    ```

**히스토그램의 용도**

- 실제 응용 프로그램의 데이터는 항상 균등한 분포도를 가지지 않는다.
- 히스토그램은 특정 칼럼이 가지는 모든 값에 대한 분포도 정보를 가지지 않지만, 각 범위(버킷)별로 레코드의 건수와 유니크한 값의 개수 정보를 가지기 때문에 훨씬 정확한 예측을 할 수 있다.

    ```sql
    -- // 히스토그램을 사용하지 않고 조회
    EXPLAIN
    SELECT *
    FROM employees
    WHERE first_name = 'Zita'
      AND birth_date BETWEEN '1950-01-01' AND '1960-01-01';
  
    +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    | id | select_type | table     | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra       |
    +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    |  1 | SIMPLE      | employees | NULL       | ref  | ix_firstname  | ix_firstname | 58      | const |  224 |    11.11 | Using where |
    +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    
    -- // 히스토그램을 사용
    ANALYZE TABLE employees
      UPDATE HISTOGRAM ON first_name, birth_date;
  
    +------------------+-----------+----------+-------------------------------------------------------+
    | Table            | Op        | Msg_type | Msg_text                                              |
    +------------------+-----------+----------+-------------------------------------------------------+
    | testdb.employees | histogram | status   | Histogram statistics created for column 'birth_date'. |
    | testdb.employees | histogram | status   | Histogram statistics created for column 'first_name'. |
    +------------------+-----------+----------+-------------------------------------------------------+
    
    -- // 위의 SELECT 쿼리 재조회
  
    +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    | id | select_type | table     | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra       |
    +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    |  1 | SIMPLE      | employees | NULL       | ref  | ix_firstname  | ix_firstname | 58      | const |  224 |    60.61 | Using where |
    +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    ```

  → 단순 통계 정보만 이용한 경우와 히스토크램을 이용한 경우의 차이가 매우 큰 것을 알 수 있다.

    ```sql
    SELECT
    SUM(
        CASE WHEN birth_date BETWEEN '1950-01-01' AND '1960-01-01' 
             THEN 1 
             ELSE 0 END
       ) / COUNT(*) AS ratio
    FROM employees 
    WHERE first_name = 'Zita';
    +--------+
    | ratio  |
    +--------+
    | 0.6384 |
    +--------+
    ```

    - 히스토그램 정보가 없으면 옵티마이저는 데이터가 균등하게 분포되어 있을 것으로 예측한다. 하지만 히스토그램이 있으면 특정 범위의 데이터가 많고 적음을 식별할 수 있다.
    - 조인의 경우에도, 히스토그램 정보가 있으면 어느 테이블을 먼저 읽어야 조인 횟수를 줄일 수 있을지 옵티마이저가 더 정확히 판단할 수 있다.

**히스토그램과 인덱스**

- 히스토그램과 인덱스는 완전히 다른 객체이기 때문에 서로 비교할 대상은 아니지만, MySQL 서버에서 인덱스는 부족한 통계 정보를 수집하기 위해 사용된다는 측면에서는 어느 정도 공통점을 가진다.
- MySQL 서버에서는 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택한다.
- **이때, 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링해서 살펴보는데, 이 작업을 인덱스 다이브(Index Dive)라고 표현한다.**
- MySQL 8.0 버전에서는 인덱스된 칼럼을 검색 조건으로 사용하는 경우, 그 칼럼의 히스토그램은 사용하지 않고 실제 인덱스 다이브를 통해 직접 수집한 정보를 활용한다.
- MySQL 8.0 버전에서 히스토그램은 주로 인덱스되지 않은 칼럼에 대한 데이터 분포를 참조하는 용도로 사용된다.
- 하지만 인덱스 다이브 작업은 어느 정도의 비용이 필요하며, 때로는 (IN 절에 많은 값을 검색하는 경우) 실행 계획 수립만으로도 상당한 인덱스 다이브를 실행하고 비용도 그만큼 커진다.

### 1.3 코스트 모델(Cost Model)

- MySQL 서버가 쿼리를 처리하기 위한 작업
    - 디스크로부터 데이터 페이지 읽기
    - 메모리(InnoDB 버퍼 풀)로부터 데이터 페이지 읽기
    - 인덱스 키 비교
    - 레코드 평가
    - 메모리 임시 테이블 작업
    - 디스크 임시 테이블 작업
- 전체 쿼리의 비용을 계산하는데 필요한 단위 작업들의 비용을 코스트 모델이라고 한다.
- 코스트 모델의 설정 테이블
    - `server_cost` : 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
    - `engine_cost` : 레코드를 가진 데이터 페이지를 가져오는데 필요한 비용 관리
- MySQL 8.0 버전의 코스트 모델에서 지원하는 단위 작업

    | type | cost_name | deafult_value | 설명 |
    | :---: | :--- | :---: | :--- |
    | engine_cost | io_block_read_cost | 1.00 | 디스크 데이터 페이지 읽기 |
    |  | memory_block_read_cost | 0.25 | 메모리 데이터 페이지 읽기 |
    | server_cost | disk_temptable_create_cost | 20.00 | 디스크 임시 테이블 생성 |
    |  | disk_temptable_row_cost | 0.50 | 디스크 임시 테이블의 레코드 읽기 |
    |  | key_compare_cost | 0.05 | 인덱스 비교 |
    |  | memory_temptable_create_cost | 1.00 | 메모리 임시 테이블 생성 |
    |  | memory_temptable_row_cost | 0.10 | 메모리 임시 테이블의 레코드 읽기 |
    |  | row_evaluate_cost | 0.10 | 레코드 비교 |

    - 단위 작업의 비용이 변경될 때 예상할 수 있는 결과
        - `key_compare_cost` 비용을 높이면 MySQL 서버 옵티마이저가 가능하면 정렬을 수행하지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.
        - `row_evaluate_cost` 비용을 높이면 풀 스캔을 실행하는 쿼리들의 비용이 높아지고, 인덱스 레인지 스캔을 사용하는 실행 계획을 선택할 가능성이 높아진다.
        - `disk_temptable_create_cost`와 `disk_temptable_row_cost` 비용을 높이면, 디스크에 임시 테이블을 만들지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.
        - `memory_temptable_create_cost`와 `memory_temptable_row_cost` 비용을 높이면, 메모리 임시 테이블을 만들지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.
        - `io_block_read_cost` 비용이 높아지면, InnoDB 버퍼 풀에 데이터 페이지가 많이 적재되어 있는 인덱스를 사용하는 실행 계획을 선택할 가능성이 높아진다.
        - `memory_block_read_cost` 비용이 높아지면, InnoDB 버퍼 풀에 적재된 데이터 페이지가 상대적으로 적다고 하더라도 그 인덱스를 사용할 가능성이 높아진다.
- 각 실행 계획의 계산된 비용(Cost) 확인

    ```sql
    -- // TREE 포맷 조회
    EXPLAIN FORMAT = TREE
    SELECT *
    FROM employees WHERE first_name = 'Matt' \G
    
    *************************** 1. row ***************************
    EXPLAIN: -> Index lookup on employees using ix_firstname (first_name='Matt')  (cost=147.01 rows=233)
    
    -- // JSON 포맷 조회
    EXPLAIN FORMAT = JSON
    SELECT *
    FROM employees WHERE first_name = 'Matt' \G
    
    *************************** 1. row ***************************
    EXPLAIN: {
      "query_block": {
        "select_id": 1,
        "cost_info": {
          "query_cost": "147.01"
        },
        "table": {
          "table_name": "employees",
          "access_type": "ref",
          "possible_keys": [
            "ix_firstname"
          ],
          "key": "ix_firstname",
          "used_key_parts": [
            "first_name"
          ],
          "key_length": "58",
          "ref": [
            "const"
          ],
          "rows_examined_per_scan": 233,
          "rows_produced_per_join": 233,
          "filtered": "100.00",
          "cost_info": {
            "read_cost": "123.71",
            "eval_cost": "23.30",
            "prefix_cost": "147.01",
            "data_read_per_join": "30K"
          },
          "used_columns": [
            "emp_no",
            "birth_date",
            "first_name",
            "last_name",
            "gender",
            "hire_date"
          ]
        }
      }
    }
    ```

  **→ 코스트 모델에서 중요한 것은 각 단위 작업에 설정되는 값에 따라 실행 계획의 비용을 파악하는 것이다.**


## 3. 실행 계획 분석

- 실행 계획이 어떤 접근 방법을 사용해서 최적화를 수행하는지, 어떤 인덱스를 사용하는지 등을 이해하는 것이 중요하다.
- 아무런 옵션 없이 `EXPLAIN` 명령을 실행하면 표 형태로 표시된다.
    - 표의 각 레코드는 사용된 테이블의 개수만큼 출력된다.
    - 실행 순서는 위에서 아래로 순서대로 표시된다. (UNION이나 상관 서브쿼리와 같은 경우 순서대로 표시되지 않을 수도 있다.)
    - 위쪽에 출력된 결과일수록(id 칼럼의 값이 작을수록) 쿼리의 바깥(Outer) 부분이거나 먼저 접근한 테이블이다.
    - 아래쪽에 출력된 결과일수록(id 칼럼의 값이 클수록) 쿼리의 안쪽(Inner) 부분이거나 나중에 접근한 테이블이다.

### 3.1 id 칼럼

- 하나의 `SELECT` 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만 **같은 id 값이 부여된다.**

    ```sql
    EXPLAIN 
    SELECT e.emp_no, e.first_name, s.from_date, s.salary
    FROM employees e, salaries s
    WHERE e.emp_no = s.emp_no
    LIMIT 10;
    
    +----+-------------+-------+------------+-------+---------------+--------------+---------+-----------------+--------+----------+-------------+
    | id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref             | rows   | filtered | Extra       |
    +----+-------------+-------+------------+-------+---------------+--------------+---------+-----------------+--------+----------+-------------+
    |  1 | SIMPLE      | e     | NULL       | index | PRIMARY       | ix_firstname | 58      | NULL            | 300596 |   100.00 | Using index |
    |  1 | SIMPLE      | s     | NULL       | ref   | PRIMARY       | PRIMARY      | 4       | testdb.e.emp_no |      9 |   100.00 | NULL        |
    +----+-------------+-------+------------+-------+---------------+--------------+---------+-----------------+--------+----------+-------------+
    ```

- 하나의 `SELECT` 문장은 1개 이상의 하위 `SELECT` 문장을 포함할 수 있는데, 단위 `SELECT` 쿼리로 구성된 실행 계획에서는 **서로 다른 id이값 부여된다.**

    ```sql
    EXPLAIN
    SELECT(
        (SELECT COUNT(*) FROM employees) + (SELECT COUNT(*) FROM departments)
    ) AS total_count;
    
    +----+-------------+-------------+------------+-------+---------------+-------------+---------+------+--------+----------+----------------+
    | id | select_type | table       | partitions | type  | possible_keys | key         | key_len | ref  | rows   | filtered | Extra          |
    +----+-------------+-------------+------------+-------+---------------+-------------+---------+------+--------+----------+----------------+
    |  1 | PRIMARY     | NULL        | NULL       | NULL  | NULL          | NULL        | NULL    | NULL |   NULL |     NULL | No tables used |
    |  3 | SUBQUERY    | departments | NULL       | index | NULL          | ux_deptname | 162     | NULL |      9 |   100.00 | Using index    |
    |  2 | SUBQUERY    | employees   | NULL       | index | NULL          | ix_hiredate | 3       | NULL | 300596 |   100.00 | Using index    |
    +----+-------------+-------------+------------+-------+---------------+-------------+---------+------+--------+----------+----------------+
    ```

- 한 가지 주의할 점은 실행 계획의 id 칼럼이 테이블의 접근 순서를 의미하지는 않는다는 것이다.

    ```sql
    EXPLAIN FORMAT=TREE
    SELECT *
    FROM dept_emp de
    WHERE de.emp_no = (
        SELECT e.emp_no
        FROM employees e
        WHERE e.first_name = 'Georgi'
          AND e.last_name = 'Facello'
        LIMIT 1
    );
    
    +---------+
    | EXPLAIN |
    +---------+
    -> Filter: (de.emp_no = (select #2))  (cost=1.10 rows=1)
        -> Index lookup on de using ix_empno_fromdate (emp_no=(select #2))  (cost=1.10 rows=1)
        -> Select #2 (subquery in condition; run only once)
            -> Limit: 1 row(s)
                -> Filter: (e.last_name = 'Facello')  (cost=253.71 rows=25)
                    -> Index lookup on e using ix_firstname (first_name='Georgi')  (cost=253.71 rows=253)
    ```

  → **쿼리의 실행 순서를 확인하기 위해서는 TABLE 포맷보다 TREE 포맷으로 확인해보면 순서를 더 정확히 알 수 있다.**


### 3.2 select_type 칼럼

- 각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼이다.
1. `SIMPLE`
    - UNION이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우 `SIMPLE`이 표시된다.
    - 쿼리 문장이 아무리 복잡하더라도 select_type이 `SIMPLE`인 단위 쿼리는 하나만 존재한다.
    - 일반적으로 제일 바깥 SELECT에 해당한다.
2. `PRIMARY`
    - UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽(Outer)에 있는 단위 쿼리에 `PRIMARY`가 표시된다.
    - select_type이 `PRIMARY`인 단위 쿼리는 하나만 존재한다.
3. `UNION`
    - UNION으로 결합하는 단위 SELECT 쿼리 가운데 두번째 이후 단위 SELECT 쿼리에 `UNION`이 표시된다.
    - UNION의 첫번째 단위 SELECT는 `DERIVED`(임시테이블)로 표시된다.

    ```sql
    EXPLAIN
    SELECT * FROM (
        (SELECT emp_no FROM employees e1 LIMIT 10) UNION ALL
        (SELECT emp_no FROM employees e2 LIMIT 10) UNION ALL
        (SELECT emp_no FROM employees e3 LIMIT 10)
    ) AS union_result;
    
    +----+-------------+------------+------------+-------+---------------+-------------+---------+------+--------+----------+-------------+
    | id | select_type | table      | partitions | type  | possible_keys | key         | key_len | ref  | rows   | filtered | Extra       |
    +----+-------------+------------+------------+-------+---------------+-------------+---------+------+--------+----------+-------------+
    |  1 | PRIMARY     | <derived2> | NULL       | ALL   | NULL          | NULL        | NULL    | NULL |     30 |   100.00 | NULL        |
    |  2 | DERIVED     | e1         | NULL       | index | NULL          | ix_hiredate | 3       | NULL | 300596 |   100.00 | Using index |
    |  3 | UNION       | e2         | NULL       | index | NULL          | ix_hiredate | 3       | NULL | 300596 |   100.00 | Using index |
    |  4 | UNION       | e3         | NULL       | index | NULL          | ix_hiredate | 3       | NULL | 300596 |   100.00 | Using index |
    +----+-------------+------------+------------+-------+---------------+-------------+---------+------+--------+----------+-------------+
    ```

4. `DEPENDENT UNION`
    - DEPENDENT는 UNION이나 UNION ALL로 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미한다.
    - 내부 쿼리가 외부의 값을 참조해서 처리되는 경우 `DEPENDENT UNION`이 표시된다.

    ```sql
    EXPLAIN
    SELECT *
    FROM employees e1 
    WHERE e1.emp_no IN (
        SELECT e2.emp_no FROM employees e2 WHERE e2.first_name = 'Matt'
        UNION ALL
        SELECT e3.emp_no FROM employees e3 WHERE e3.last_name = 'Matt'
    );
    
    +----+--------------------+-------+------------+--------+----------------------+---------+---------+------+--------+----------+-------------+
    | id | select_type        | table | partitions | type   | possible_keys        | key     | key_len | ref  | rows   | filtered | Extra       |
    +----+--------------------+-------+------------+--------+----------------------+---------+---------+------+--------+----------+-------------+
    |  1 | PRIMARY            | e1    | NULL       | ALL    | NULL                 | NULL    | NULL    | NULL | 300596 |   100.00 | Using where |
    |  2 | DEPENDENT SUBQUERY | e2    | NULL       | eq_ref | PRIMARY,ix_firstname | PRIMARY | 4       | func |      1 |     5.00 | Using where |
    |  3 | DEPENDENT UNION    | e3    | NULL       | eq_ref | PRIMARY              | PRIMARY | 4       | func |      1 |    10.00 | Using where |
    +----+--------------------+-------+------------+--------+----------------------+---------+---------+------+--------+----------+-------------+
    ```

5. `UNION RESULT`
    - UNION RESULT는 UNION 결과를 담아두는 테이블을 의미한다.
    - UNION RESULT는 실제 쿼리에서 단위 쿼리가 아니기 때문에 별도의 id 값은 부여되지 않는다.
    - MySQL 8.0 이전 버전에서는 `UNION ALL`이나 `UNION`(또는 `UNION DISTINCT`) 쿼리의 UNION 결과를 임시테이블로 생성했다.
    - MySQL 8.0 버전부터 `UNION ALL`의 경우에는 임시테이블을 사용하지 않도록 개선되었다.

        ```sql
        EXPLAIN
        SELECT emp_no FROM salaries WHERE salary > 100000
        UNION DISTINCT
        SELECT emp_no FROM dept_emp WHERE from_date > '2001-01-01';
        
        +----+----------------+------------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
        | id | select_type    | table      | partitions | type  | possible_keys                 | key         | key_len | ref  | rows   | filtered | Extra                    |
        +----+----------------+------------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
        |  1 | PRIMARY        | salaries   | NULL       | range | ix_salary                     | ix_salary   | 4       | NULL | 188518 |   100.00 | Using where; Using index |
        |  2 | UNION          | dept_emp   | NULL       | range | ix_fromdate,ix_empno_fromdate | ix_fromdate | 3       | NULL |   5325 |   100.00 | Using where; Using index |
        | NULL | UNION RESULT | <union1,2> | NULL       | ALL   | NULL                          | NULL        | NULL    | NULL |   NULL |     NULL | Using temporary          |
        +----+----------------+------------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
        
        EXPLAIN
        SELECT emp_no FROM salaries WHERE salary > 100000
        UNION ALL
        SELECT emp_no FROM dept_emp WHERE from_date > '2001-01-01';
        
        +----+-------------+----------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
        | id | select_type | table    | partitions | type  | possible_keys                 | key         | key_len | ref  | rows   | filtered | Extra                    |
        +----+-------------+----------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
        |  1 | PRIMARY     | salaries | NULL       | range | ix_salary                     | ix_salary   | 4       | NULL | 188518 |   100.00 | Using where; Using index |
        |  2 | UNION       | dept_emp | NULL       | range | ix_fromdate,ix_empno_fromdate | ix_fromdate | 3       | NULL |   5325 |   100.00 | Using where; Using index |
        +----+-------------+----------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
        ```

        - table 칼럼의 `<union1,2>`은 id가 1인 단위 쿼리의 조회 결과와 id가 2인 단위 쿼리의 조회 결과를 UNION 했다는 것을 의미한다.
6. `SUBQUERY`
    - select_type의 SUBQUERY는 FROM절 이외에서 사용되는 서브쿼리만을 의미한다.
    - **FROM 절에 사용된 서브쿼리는 select_type이 `DERIVED`로 표시되고, 그 밖의 위치에서 사용된 서브쿼리는 전부 `SUBQUERY`로 표시된다.**

        ```sql
        EXPLAIN
        SELECT e.first_name,
               (SELECT COUNT(*) 
                FROM dept_emp de, dept_manager dm 
                WHERE dm.dept_no = de.dept_no
               ) AS cnt
        FROM employees e
        WHERE e.emp_no = 10001;
        
        +----+-------------+-------+------------+-------+---------------+---------+---------+-------------------+-------+----------+-------------+
        | id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref               | rows  | filtered | Extra       |
        +----+-------------+-------+------------+-------+---------------+---------+---------+-------------------+-------+----------+-------------+
        |  1 | PRIMARY     | e     | NULL       | const | PRIMARY       | PRIMARY | 4       | const             |     1 |   100.00 | NULL        |
        |  2 | SUBQUERY    | dm    | NULL       | index | PRIMARY       | PRIMARY | 20      | NULL              |    24 |   100.00 | Using index |
        |  2 | SUBQUERY    | de    | NULL       | ref   | PRIMARY       | PRIMARY | 16      | testdb.dm.dept_no | 41392 |   100.00 | Using index |
        +----+-------------+-------+------------+-------+---------------+---------+---------+-------------------+-------+----------+-------------+
        ```

    - 서브쿼리는 사용하는 위치에 따라 각각 다른 이름을 갖는다.
        - 중첩된 쿼리(Nested Query) : SELECT 칼럼에 사용된 서브쿼리
        - 서브쿼리(Subquery) : WHERE 절에 사용된 서브쿼리
        - 파생 테이블(Derived Table) : FROM 절에 사용된 서브쿼리 (=인라인 뷰, =서브 셀렉트)
    - 서브쿼리가 반환하는 값의 특성에 따라 분류하기도 한다.
        - 스칼라 서브쿼리(Scalar Subquery) : 하나의 값만(칼럼이 단 하나인 레코드 1건) 반환하는 쿼리
        - 로우 서브쿼리(Row Subquery) : 칼럼의 개수와 관계없이 하나의 레코드만 반환하는 쿼리
7. `DEPENDENT SUBQUERY`
    - 서브쿼리가 바깥쪽(Outer) SELECT 쿼리에 정의된 칼럼을 사용하는 경우 `DEPENDENT SUBQUERY`가 표시된다.
        - 안쪽의 서브쿼리 결과가 바깥쪽 칼럼에 의존적이기 때문에 `DEPENDENT` 키워드가 붙는다.
        - 외부 쿼리가 먼저 수행된 후 내부 쿼리(서브쿼리)가 실행되므로, 일반 서브쿼리보다 처리 속도가 느릴 때가 많다.

    ```sql
    EXPLAIN
    SELECT e.first_name,
           (SELECT COUNT(*) 
            FROM dept_emp de, dept_manager dm 
            WHERE dm.dept_no = de.dept_no 
              AND de.emp_no = e.emp_no
           ) AS cnt
    FROM employees e
    WHERE e.first_name = 'Matt';
    
    +----+--------------------+-------+------------+------+---------------------------+-------------------+---------+-------------------+------+----------+-------------+
    | id | select_type        | table | partitions | type | possible_keys             | key               | key_len | ref               | rows | filtered | Extra       |
    +----+--------------------+-------+------------+------+---------------------------+-------------------+---------+-------------------+------+----------+-------------+
    |  1 | PRIMARY            | e     | NULL       | ref  | ix_firstname              | ix_firstname      | 58      | const             |  233 |   100.00 | Using index |
    |  2 | DEPENDENT SUBQUERY | de    | NULL       | ref  | PRIMARY,ix_empno_fromdate | ix_empno_fromdate | 4       | testdb.e.emp_no   |    1 |   100.00 | Using index |
    |  2 | DEPENDENT SUBQUERY | dm    | NULL       | ref  | PRIMARY                   | PRIMARY           | 16      | testdb.de.dept_no |    2 |   100.00 | Using index |
    +----+--------------------+-------+------------+------+---------------------------+-------------------+---------+-------------------+------+----------+-------------+
    ```

8. `DERIVED`
    - **MySQL은 FROM 절의 서브쿼리를 임시 테이블로 만들어서 처리한다.**
    - DERIVED는 단위 SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다.
        - **select_type이 DERIVED인 경우에 생성되는 임시 테이블을 파생 테이블이라고도 한다.**
        - MySQL 5.5 버전까지는 파생 테이블에는 인덱스가 전혀 없으므로 다른 테이블과 조인할 때 성능상 불리할 때가 많았다.
        - MySQL 5.6 버전부터는 옵티마이저 옵션에 따라 임시 테이블에도 인덱스를 추가해서 만들 수 있게 최적화되었다.

        ```sql
        EXPLAIN
        SELECT *
        FROM (SELECT de.emp_no FROM dept_emp de GROUP BY de.emp_no) tb,
          employees e
        WHERE e.emp_no = tb.emp_no;
        
        +----+-------------+------------+------------+--------+---------------------------------------+-------------------+---------+-----------+--------+----------+-------------+
        | id | select_type | table      | partitions | type   | possible_keys                         | key               | key_len | ref       | rows   | filtered | Extra       |
        +----+-------------+------------+------------+--------+---------------------------------------+-------------------+---------+-----------+--------+----------+-------------+
        |  1 | PRIMARY     | <derived2> | NULL       | ALL    | NULL                                  | NULL              | NULL    | NULL      | 331143 |   100.00 | NULL        |
        |  1 | PRIMARY     | e          | NULL       | eq_ref | PRIMARY                               | PRIMARY           | 4       | tb.emp_no |      1 |   100.00 | NULL        |
        |  2 | DERIVED     | de         | NULL       | index  | PRIMARY,ix_fromdate,ix_empno_fromdate | ix_empno_fromdate | 7       | NULL      | 331143 |   100.00 | Using index |
        +----+-------------+------------+------------+--------+---------------------------------------+-------------------+---------+-----------+--------+----------+-------------+
        ```

    - MySQL 5.6 버전부터는 옵티마이저 옵션에 따라 FROM 절의 서브쿼리를 외부 쿼리와 통합하는 형태의 최적화가 수행되기도 한다.

   **→ 서브쿼리에 대한 최적화가 개선되었지만, 옵티마이저가 처리하는데 여전히 한계가 있으므로 가능하면 DERIVED 형태의 실행 계획을 조인으로 바꿔주는 것이 좋다.**

   **→ selet_type이 DERIVED인 것은 쿼리를 튜닝할 때 가장 먼저 확인해야 하는 부분이다.**
   서브쿼리는 개발자가 작성하기 편하지만, 쿼리의 성능은 떨어지므로 나중에는 반드시 서브쿼리를 조인으로 풀어서 고쳐 쓰는 것을 권장한다.

9. `DEPENDENT DERIVED`
    - MySQL 8.0 버전부터는 래터럴 조인(LATERAL JOIN) 기능이 추가되면서 FROM 절의 서브쿼리에서도 외부 칼럼을 참조할 수 있게 되었다.

        ```sql
        EXPLAIN
        SELECT *
        FROM employees e
        LEFT JOIN LATERAL
          (SELECT *
           FROM salaries s
           WHERE s.emp_no = e.emp_no
           ORDER BY s.from_date DESC
           LIMIT 2
          ) AS s2
        ON s2.emp_no = e.emp_no;
        
        +----+-------------------+------------+------------+------+---------------+-------------+---------+-----------------+--------+----------+----------------------------+
        | id | select_type       | table      | partitions | type | possible_keys | key         | key_len | ref             | rows   | filtered | Extra                      |
        +----+-------------------+------------+------------+------+---------------+-------------+---------+-----------------+--------+----------+----------------------------+
        |  1 | PRIMARY           | e          | NULL       | ALL  | NULL          | NULL        | NULL    | NULL            | 300596 |   100.00 | Rematerialize (<derived2>) |
        |  1 | PRIMARY           | <derived2> | NULL       | ref  | <auto_key0>   | <auto_key0> | 4       | testdb.e.emp_no |      2 |   100.00 | NULL                       |
        |  2 | DEPENDENT DERIVED | s          | NULL       | ref  | PRIMARY       | PRIMARY     | 4       | testdb.e.emp_no |      9 |   100.00 | Using filesort             |
        +----+-------------------+------------+------------+------+---------------+-------------+---------+-----------------+--------+----------+----------------------------+
        ```

10. `UNCACHEABLE SUBQUERY`
    - 하나의 쿼리 문장에 서브쿼리가 하나만 있더라도 실제 그 서브쿼리가 한 번만 실행되는 것은 아니다.
    - 조건이 똑같은 서브쿼리가 실행될 때는 다시 실행하지 않고 이전의 실행 결과를 그대로 사용할 수 있게 서브쿼리의 결과를 내부적인 캐시 공간에 담아둔다.
    - 캐시를 사용하는 방법 비교
        - `SUBQUERY`: 바깥쪽(Outer)의 영향을 받지 않으므로 처음 한 번만 실행해서 그 결과를 캐시하고 필요할 때 캐시된 결과를 이용한다.
        - `DEPENDENT SUBQUERY`: 의존하는 바깥쪽(Outer) 쿼리의 칼럼 값 단위로 캐시해두고 사용한다.
    - 서브쿼리에 포함된 요소에 의해 캐시 자체가 불가능한 경우 `UNCACHEABLE SUBQUERY`가 표시된다.
    - 서브쿼리에서 캐시를 사용하지 못하는 요소
        - 사용자 변수가 서브쿼리에 사용된 경우
        - NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리 내에 사용된 경우
        - UUID()나 RAND()와 같이 결과값이 호출할 때마다 달라지는 함수가 서브쿼리에 사용된 경우

        ```sql
        EXPLAIN
        SELECT *
        FROM employees e
        WHERE e.emp_no = (
            SELECT @status FROM dept_emp de WHERE de.dept_no = 'd0005'
        );
        
        +----+----------------------+-------+------------+------+---------------------------------------+---------+---------+-------+--------+----------+--------------------------+
        | id | select_type          | table | partitions | type | possible_keys                         | key     | key_len | ref   | rows   | filtered | Extra                    |
        +----+----------------------+-------+------------+------+---------------------------------------+---------+---------+-------+--------+----------+--------------------------+
        |  1 | PRIMARY              | e     | NULL       | ALL  | NULL                                  | NULL    | NULL    | NULL  | 300596 |   100.00 | Using where              |
        |  2 | UNCACHEABLE SUBQUERY | de    | NULL       | ref  | PRIMARY,ix_fromdate,ix_empno_fromdate | PRIMARY | 16      | const |      1 |   100.00 | Using where; Using index |
        +----+----------------------+-------+------------+------+---------------------------------------+---------+---------+-------+--------+----------+--------------------------+
        ```

11. `UNCACHEABLE UNION`
    - UNION과 UNCACHEABLE 키워드의 속성이 혼합된 형태를 의미한다.
12. `MATERIALIZED`
    - MySQL 5.6 버전부터 도입된 select_type으로, 주로 FROM 절이나 IN(subquery) 형태의 쿼리에 서브쿼리의 최적화를 위해 사용된다.
        - MySQL 5.6 버전까지는 employees 테이블을 읽어서 employees 테이블의 레코드마다 salaries 테이블을 읽는 서브쿼리가 실행되는 형태로 처리됐다.
        - MySQL 5.7 버전부터는 서브쿼리의 내용을 임시 테이블로 구체화(Meterialization)한 후, 임시 테이블과 employees 테이블을 조인하는 형태로 최적화되어 처리된다.

    ```sql
    EXPLAIN
    SELECT *
    FROM employees e
    WHERE e.emp_no IN (
        SELECT emp_no FROM salaries WHERE salary BETWEEN 100 AND 1000
    );
    
    +----+--------------+-------------+------------+--------+-------------------+-----------+---------+--------------------+------+----------+--------------------------+
    | id | select_type  | table       | partitions | type   | possible_keys     | key       | key_len | ref                | rows | filtered | Extra                    |
    +----+--------------+-------------+------------+--------+-------------------+-----------+---------+--------------------+------+----------+--------------------------+
    |  1 | SIMPLE       | <subquery2> | NULL       | ALL    | NULL              | NULL      | NULL    | NULL               | NULL |   100.00 | NULL                     |
    |  1 | SIMPLE       | e           | NULL       | eq_ref | PRIMARY           | PRIMARY   | 4       | <subquery2>.emp_no |    1 |   100.00 | NULL                     |
    |  2 | MATERIALIZED | salaries    | NULL       | range  | PRIMARY,ix_salary | ix_salary | 4       | NULL               |    1 |   100.00 | Using where; Using index |
    +----+--------------+-------------+------------+--------+-------------------+-----------+---------+--------------------+------+----------+--------------------------+
    ```


### 3.3 table 칼럼

- MySQL 서버의 실행 계획은 단위 SELECT 쿼리 기준이 아니라 테이블 기준으로 표시된다.
- 별도의 테이블을 사용하지 않는 SELECT 쿼리인 경우에는 table 칼럼에 NULL이 표시된다.

    ```sql
    EXPLAIN SELECT NOW();
    EXPLAIN SELECT NOW() FROM DUAL;
    
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
    |  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
    ```

    - MySQL 서버는 별도의 테이블을 사용하지 않는 SELECT 쿼리인 경우에는 table 칼럼에 NULL이 표시된다.
- table 칼럼에 `<derived N>` 또는 `<union M,N>`과 같이 “<>”로 둘러싸인 이름이 명시되는 경우 임시 테이블을 의미한다.

    ```sql
    EXPLAIN
    SELECT * 
    FROM 
        (SELECT de.emp_no FROM dept_emp de GROUP BY de.emp_no) tb,
        employees e
    WHERE e.emp_no = tb.emp_no;
    
    +----+-------------+------------+------------+--------+---------------------------------------+-------------------+---------+-----------+--------+----------+-------------+
    | id | select_type | table      | partitions | type   | possible_keys                         | key               | key_len | ref       | rows   | filtered | Extra       |
    +----+-------------+------------+------------+--------+---------------------------------------+-------------------+---------+-----------+--------+----------+-------------+
    |  1 | PRIMARY     | <derived2> | NULL       | ALL    | NULL                                  | NULL              | NULL    | NULL      | 331143 |   100.00 | NULL        |
    |  1 | PRIMARY     | e          | NULL       | eq_ref | PRIMARY                               | PRIMARY           | 4       | tb.emp_no |      1 |   100.00 | NULL        |
    |  2 | DERIVED     | de         | NULL       | index  | PRIMARY,ix_fromdate,ix_empno_fromdate | ix_empno_fromdate | 7       | NULL      | 331143 |   100.00 | Using index |
    +----+-------------+------------+------------+--------+---------------------------------------+-------------------+---------+-----------+--------+----------+-------------+
    ```

    - `<derived2>` : 단위 SELECT 쿼리의 id 값이 2인 실행 계획으로부터 만들어진 파생 테이블 → id 값이 2인 실행 계획이 먼저 실행되어야 함
    - `select_type= DERIVED`, `table=de` : dept_emp 테이블을 읽어서 파생 테이블을 생성
    - id 값은 실행 계획은 조인 쿼리로 실행되는데, 더 먼저 표시된 테이블이 드라이빙 테이블
- select_type이 MATERIALIZED인 실행 계획에서 `<subquery N>`은 서브쿼리의 결과를 구체화해서 임시 테이블로 만들었다는 의미로, `<derived N>`과 같은 방법으로 해석한다.


### 3.4 partitions 칼럼

- MySQL 5.7 버전까지는 옵티마이저가 사용하는 파티션 목록을 `EXPLAIN PARTITION` 으로 확인해야 한다.
- MySQL 8.0 버전부터는 `EXPLAIN` 명령으로 파티션 관련 실행 계획을 확인할 수 있다.
- 파티션 테이블 생성

    ```sql
    CREATE TABLE employees_2 (
      emp_no INT NOT NULL,
      birth_date DATE NOT NULL,
      first_name VARCHAR(14) NOT NULL,
      last_name VARCHAR(16) NOT NULL,
      gender ENUM('M', 'F') NOT NULL,
      hire_date DATE NOT NULL,
      PRIMARY KEY(emp_no, hire_date)
    ) PARTITION BY RANGE COLUMNS(hire_date)
    (  
      PARTITION p1986_1990 VALUES LESS THAN ('1990-01-01'),
      PARTITION p1991_1995 VALUES LESS THAN ('1996-01-01'),
      PARTITION p1996_2000 VALUES LESS THAN ('2000-01-01'),
      PARTITION p2001_2005 VALUES LESS THAN ('2006-01-01')
    );
    
    INSERT INTO employees_2 SELECT * FROM employees;
    ```

- 파티션 목록 조회

    ```sql
    EXPLAIN
    SELECT *
    FROM employees_2
    WHERE hire_date BETWEEN '1999-11-15' AND '2000-01-15';
    
    +----+-------------+-------------+-----------------------+------+---------------+------+---------+------+-------+----------+-------------+
    | id | select_type | table       | partitions            | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |
    +----+-------------+-------------+-----------------------+------+---------------+------+---------+------+-------+----------+-------------+
    |  1 | SIMPLE      | employees_2 | p1996_2000,p2001_2005 | ALL  | NULL          | NULL | NULL    | NULL | 21736 |    11.11 | Using where |
    +----+-------------+-------------+-----------------------+------+---------------+------+---------+------+-------+----------+-------------+
    ```
    - `p1996_2000`, `p2001_2005` 테이블만 테이블 풀 스캔을 수행한다.
    - RDBMS에서 지원하는 파티션은 물리적으로 개별 테이블처럼 별도의 저장공간을 가지기 때문에 type 컬림에 ALL로 표시된다.
- 파티션이 있는 테이블에서 불필요한 테이블을 제외하고 필요한 테이블만 선택하는 작업을 파티션 프루닝이라고 한다.


### 3.5 type 칼럼

- type 칼럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다.
    - type 칼럼의 값을 보고 인덱스를 사용했는지, 풀 테이블 스캔을 사용했는지 등을 확인 할 수 있.

  → 실행 계획에서 type 칼럼은 반드시 체크해야 할 중요한 정보이다.

- **type 칼럼의 접근 방법 (성능이 빠른 순서)**

    | system | 실무에서 잘 사용되는 경우 거의 없음 |
    | --- | --- |
    | const | 조인의 순서와 관계 없이 프라이머리 키나 유니크 키의 모든 칼럼에 대해 동등 조건으로 검색하면 반드시 1건이 레코드만 반환 |
    | eq_ref | 조인에서 첫 번째 읽은 테이블의 칼럼값을 이용해 두 번째 테이블을 프라이머리 키나 유니크 키로 동등 비교 조건 검색하면 반드시 1건의 레코드만 반환 |
    | ref | 조인의 순서와 인덱스의 종류에 관계 없이 동등 조건으로 검색하면  1건의 레코드만 반환된다는 보장이 없음 |
    | fulltext | 전문 검색(Full-text Search) 인덱스를 사용 |
    | ref_or_null | ref에서 NULL 비교가 추가 |
    | unique_subquery | IN(subquery) 형태의 조건에서 subquery의 반환 값에는 중복이 없으므로 별도의 중복 제거 작업이 필요하지 않음 |
    | index_subquery | IN(sunquery) 형태의 조건에서 subquery의 반환 값에 중복된 값이 있을 수 있지만 인덱스를 이용해 중복된 값을 제거할 수 있음 |
    | rage | 범위 검색시 사용되는 쿼리로 애플리케이션에서 가장 많이 사용됨 |
    | index_merge | 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어 낸 후 그 결과를 병합해서 처리 |
    | index | 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의 |
    | all | 테이블을 처음부터 끝까지 전부 읽어서 (체크 조건이 존재할 때) 불필요한 레코드를 제거하고 레코드를 반환 |
- 하나의 단위 SELECT 쿼리에서 하나의 type 칼럼만 사용된다.
- ALL을 제외한 나머지는 모두 인덱스를 사용하며, index_merge를 제외한 나머지는 모두 하나의 인덱스만 사용한다.

1. **`system`**
    - **레코드가 1건만 존재하거나 1건도 없는 테이블을 참조하는 방식이다.**

        ```sql
        -- // MyISAM 엔진
        CREATE TABLE tb_dual (fd1 INT NOT NULL) ENGINE=MyISAM;
        INSERT INTO tb_dual VALUES (1);
        
        EXPLAIN SELECT fd1 FROM tb_dual;
        +----+-------------+---------+------------+--------+---------------+------+---------+------+------+----------+-------+
        | id | select_type | table   | partitions | type   | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
        +----+-------------+---------+------------+--------+---------------+------+---------+------+------+----------+-------+
        |  1 | SIMPLE      | tb_dual | NULL       | system | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |
        +----+-------------+---------+------------+--------+---------------+------+---------+------+------+----------+-------+
        
        -- // InnoDB 엔진 - type 칼럼이 ALL 또는 index로 표시될 가능성이 크다.
        CREATE TABLE tb_dual_2 (fd1 INT NOT NULL) ENGINE=InnoDB;
        INSERT INTO tb_dual_2 VALUES (1);
        
        EXPLAIN SELECT fd1 FROM tb_dual_2;
        +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------+
        | id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
        +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------+
        |  1 | SIMPLE      | tb_dual_2 | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |
        +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------+
        ```

    → system은 테이블에 레코드가 1건 이하인 경우에만 사용할 수 있으므로 실제 애플리케이션에서 사용되는 쿼리에서는 거의 보이지 않는 실행 계획이다.

2. **`const`**
    - **WHERE 조건절에 프라이머리 키나 유니크 키 칼럼을 이용할 수 있으며, 레코드를 1건만 반환하는 쿼리의 처리 방식이다.**
    - 이 방식을 유니크 인덱스 스캔이라고도 한다.

        ```sql
        EXPLAIN
        SELECT * FROM employees WHERE emp_no = 10001;
        +----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
        | id | select_type | table     | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
        +----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
        |  1 | SIMPLE      | employees | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
        +----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
        ```

    - 다중 칼럼으로 구성된 프라이머리 키에서 일부만 조건으로 사용할 때는 type에 const가 아닌 ref로 표시된다.

        ```sql
        EXPLAIN
        SELECT * FROM dept_emp WHERE dept_no = 'd005';
        +----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
        | id | select_type | table    | partitions | type | possible_keys | key     | key_len | ref   | rows   | filtered | Extra |
        +----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
        |  1 | SIMPLE      | dept_emp | NULL       | ref  | PRIMARY       | PRIMARY | 16      | const | 165571 |   100.00 | NULL  |
        +----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
        ```

    - 프라이머리 키나 유니크 인덱스의 모든 칼럼을 동등 조건으로 WHERE 절에 명시하면 const 접근 방법을 사용할 수 있다.

        ```sql
        EXPLAIN
        SELECT * FROM dept_emp WHERE dept_no = 'd005' AND emp_no = 10001;
        +----+-------------+----------+------------+-------+---------------------------+---------+---------+-------------+------+----------+-------+
        | id | select_type | table    | partitions | type  | possible_keys             | key     | key_len | ref         | rows | filtered | Extra |
        +----+-------------+----------+------------+-------+---------------------------+---------+---------+-------------+------+----------+-------+
        |  1 | SIMPLE      | dept_emp | NULL       | const | PRIMARY,ix_empno_fromdate | PRIMARY | 20      | const,const |    1 |   100.00 | NULL  |
        +----+-------------+----------+------------+-------+---------------------------+---------+---------+-------------+------+----------+-------+
        ```

    - 실행 계획의 type이 const 인 경우, 옵티마이저가 쿼리를 최적화하는 단계에서 쿼리를 먼저 실행해서 상수화한다.

        ```sql
        EXPLAIN
        SELECT COUNT(*)
        FROM employees e1
        WHERE first_name = (
            SELECT first_name FROM employees e2 WHERE emp_no = 10001
        );
        
        +----+-------------+-------+------------+-------+---------------+--------------+---------+-------+------+----------+--------------------------+
        | id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref   | rows | filtered | Extra                    |
        +----+-------------+-------+------------+-------+---------------+--------------+---------+-------+------+----------+--------------------------+
        |  1 | PRIMARY     | e1    | NULL       | ref   | ix_firstname  | ix_firstname | 58      | const |  253 |   100.00 | Using where; Using index |
        |  2 | SUBQUERY    | e2    | NULL       | const | PRIMARY       | PRIMARY      | 4       | const |    1 |   100.00 | NULL                     |
        +----+-------------+-------+------------+-------+---------------+--------------+---------+-------+------+----------+--------------------------+
        
        -- // 실제 옵티마이저가 최적화되는 시점에 변환되는 쿼리
        SELECT COUNT(*)
        FROM employees e1
        WHERE first_name = 'Georgi'
        ```

3. **`eq_ref`**
    - **조인 쿼리에서 드라이빙 테이블의 칼럼 값을 드리븐 테이블의 프라이머리 키나 유니크 키로 검색 조건에 사용되는 실행 계획에서 표시된다.**
        - 두 번째 이후에 읽히는 테이블의 유니크 인덱스는 `NOT NULL` 이어야 한다.
        - 다중 칼럼으로 만들어진 프라이머리 키나 유니크 인덱스라면 모든 칼럼이 비교 조건에 사용되어야 한다.
        - 두 번째 이후에 읽는 테이블은 반드시 1건만 존재해야 한다는 보장이 있어야 한다.

        ```sql
        EXPLAIN
        SELECT *
        FROM dept_emp de, employees e
        WHERE e.emp_no = de.emp_no AND de.dept_no = 'd005';
        +----+-------------+-------+------------+--------+---------------------------+---------+---------+------------------+--------+----------+-------+
        | id | select_type | table | partitions | type   | possible_keys             | key     | key_len | ref              | rows   | filtered | Extra |
        +----+-------------+-------+------------+--------+---------------------------+---------+---------+------------------+--------+----------+-------+
        |  1 | SIMPLE      | de    | NULL       | ref    | PRIMARY,ix_empno_fromdate | PRIMARY | 16      | const            | 165571 |   100.00 | NULL  |
        |  1 | SIMPLE      | e     | NULL       | eq_ref | PRIMARY                   | PRIMARY | 4       | testdb.de.emp_no |      1 |   100.00 | NULL  |
        +----+-------------+-------+------------+--------+---------------------------+---------+---------+------------------+--------+----------+-------+
        ```

4. **`ref`**
    - **인덱스의 종류와 관계 없이 동등 조건으로 검색할 때는 ref 접근 방법이 사용된다.**
    - `eq_ref`와 달리 조인의 순서와 관계 없이 사용되며, 프라이머리 키나 유니크 키 제약 조건도 없다.
    - 동등 조건으로만 비교되므로 매우 빠른 레코드 조회 방법이다.

        ```sql
        EXPLAIN
        SELECT * FROM dept_emp WHERE dept_no = 'd0005';
        +----+-------------+----------+------------+------+---------------+---------+---------+-------+------+----------+-------------+
        | id | select_type | table    | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |
        +----+-------------+----------+------------+------+---------------+---------+---------+-------+------+----------+-------------+
        |  1 | SIMPLE      | dept_emp | NULL       | ref  | PRIMARY       | PRIMARY | 16      | const |    1 |   100.00 | Using where |
        +----+-------------+----------+------------+------+---------------+---------+---------+-------+------+----------+-------------+
        ```

    **→ const, eq_ref, ref 모두 WHERE 조건절에 사용하는 비교 연산자는 동등 비교 연산자(`=` 또는 `<=>`)여야 하며, 이 세 가지 방법은 성능상 문제를 일으키지 않는 방법이다.**

5. **`fulltext`**
    - **MySQL 서버의 전문 검색(Full-text Search) 인덱스를 사용해 레코드를 읽는 접근 방법이다.**
    - 전문 검색 인덱스는 통계 정보가 관리되지 않으며, 전문 검색 인덱스를 사용하려면 전혀 다른 SQL 인덱스를 사용해야 한다.
    - MySQL에서 전문 검색 인덱스는 우선순위가 상당히 높은데, 경험상 **인덱스를 이용하는 range 방식에 비해 빠르지 않다.**

        ```sql
        CREATE TABLE employee_name (
            emp_no INT NOT NULL,
            first_name VARCHAR(14) NOT NULL,
            last_name VARCHAR(16) NOT NULL,
            PRIMARY KEY (emp_no),
            FULLTEXT KEY fx_name (first_name, last_name) WITH PARSER ngram
        ) ENGINE=InnoDB;
        
        -- // type이 const인 경우 전문 검색 인덱스를 사용하지 않음
        EXPLAIN
        SELECT *
        FROM employee_name
        WHERE emp_no = 10001
          AND emp_no BETWEEN 10001 AND 10005
          AND MATCH(first_name, last_name) AGAINST ('Facello' IN BOOLEAN MODE);
        +----+-------------+---------------+------------+-------+-----------------+---------+---------+-------+------+----------+-------------+
        | id | select_type | table         | partitions | type  | possible_keys   | key     | key_len | ref   | rows | filtered | Extra       |
        +----+-------------+---------------+------------+-------+-----------------+---------+---------+-------+------+----------+-------------+
        |  1 | SIMPLE      | employee_name | NULL       | const | PRIMARY,fx_name | PRIMARY | 4       | const |    1 |    11.11 | Using where |
        +----+-------------+---------------+------------+-------+-----------------+---------+---------+-------+------+----------+-------------+
        
        -- // type이 rage인 경우 전문 검색 인덱스 사용
        EXPLAIN
        SELECT *
        FROM employee_name
        WHERE emp_no BETWEEN 10001 AND 10005
          AND MATCH(first_name, last_name) AGAINST ('Facello' IN BOOLEAN MODE);
        +----+-------------+---------------+------------+----------+-----------------+---------+---------+-------+------+----------+-----------------------------------+
        | id | select_type | table         | partitions | type     | possible_keys   | key     | key_len | ref   | rows | filtered | Extra                             |
        +----+-------------+---------------+------------+----------+-----------------+---------+---------+-------+------+----------+-----------------------------------+
        |  1 | SIMPLE      | employee_name | NULL       | fulltext | PRIMARY,fx_name | fx_name | 0       | const |    1 |   100.00 | Using where; Ft_hints: no_ranking |
        +----+-------------+---------------+------------+----------+-----------------+---------+---------+-------+------+----------+-----------------------------------+
        ```

6. **`ref_or_null`**
    - **`ref`에서 NULL 비교가 추가된 방법이다.**

        ```sql
        EXPLAIN
        SELECT * FROM titles
        WHERE to_date = '1985-03-01' 
          OR to_date IS NULL;
        +----+-------------+--------+------------+-------------+---------------+-----------+---------+-------+------+----------+--------------------------+
        | id | select_type | table  | partitions | type        | possible_keys | key       | key_len | ref   | rows | filtered | Extra                    |
        +----+-------------+--------+------------+-------------+---------------+-----------+---------+-------+------+----------+--------------------------+
        |  1 | SIMPLE      | titles | NULL       | ref_or_null | ix_todate     | ix_todate | 4       | const |    2 |   100.00 | Using where; Using index |
        +----+-------------+--------+------------+-------------+---------------+-----------+---------+-------+------+----------+--------------------------+
        ```

7. **`unique_subquery`**
    - WHERE 조건절에 사용될 수 있는 IN(subquery) 형태의 쿼리를 위한 접근 방법이다.
    - **서브쿼리에서 중복되지 않는 유니크한 값만 반환할 때 이 접근 방법을 사용한다.**

    ```sql
    EXPLAIN
    SELECT * FROM departments
    WHERE dept_no IN ( SELECT dept_no FROM dept_emp WHERE emp_no = 10001 );
    +----+-------------+-------------+------------+--------+---------------------------+-------------------+---------+-------------------------+------+----------+-------------+
    | id | select_type | table       | partitions | type   | possible_keys             | key               | key_len | ref                     | rows | filtered | Extra       |
    +----+-------------+-------------+------------+--------+---------------------------+-------------------+---------+-------------------------+------+----------+-------------+
    |  1 | SIMPLE      | dept_emp    | NULL       | ref    | PRIMARY,ix_empno_fromdate | ix_empno_fromdate | 4       | const                   |    1 |   100.00 | Using index |
    |  1 | SIMPLE      | departments | NULL       | eq_ref | PRIMARY                   | PRIMARY           | 16      | testdb.dept_emp.dept_no |    1 |   100.00 | NULL        |
    +----+-------------+-------------+------------+--------+---------------------------+-------------------+---------+-------------------------+------+----------+-------------+
    
    -- // MySQL 8.0 버전에서 세미조인을 최적화 하는 기능이 추가되어, 세미 조인 최적화 옵션을 off로 변경한다.
    SET optimizer_switch = 'semijoin=off';
    +----+-------------+-------------+------------+------+---------------------------------------+-------------------+---------+-------+------+----------+-------------+
    | id | select_type | table       | partitions | type | possible_keys                         | key               | key_len | ref   | rows | filtered | Extra       |
    +----+-------------+-------------+------------+------+---------------------------------------+-------------------+---------+-------+------+----------+-------------+
    |  1 | PRIMARY     | departments | NULL       | ALL  | NULL                                  | NULL              | NULL    | NULL  |    9 |   100.00 | Using where |
    |  2 | SUBQUERY    | dept_emp    | NULL       | ref  | PRIMARY,ix_fromdate,ix_empno_fromdate | ix_empno_fromdate | 4       | const |    1 |   100.00 | Using index |
    +----+-------------+-------------+------------+------+---------------------------------------+-------------------+---------+-------+------+----------+-------------+
    ```

8. **`inddex_subquery`**
    - IN (subquery)는 괄호 안에 있는 값의 목록에서 중복된 값을 제거한다.
    - unique_subquey는 중복된 값이 없으므로 별도의 중복을 제거할 필요가 없지만 그렇지 않은 경우에는 중복된 값을 제거해야 한다.
    - **IN (subquery)에서 중복된 값을 제거할 때 인덱스를 이용할 수 있는 경우 index_subquery 방식이 사용된다.**
9. **`range`**
    - **인덱스 레인지 스캔 형태의 방법이다.**
    - range는 범위로 검색하는 경우를 의미하는데, 주로  `<`, `>`, `IS NULL`, `BETWEEN`, `IN`, `LIKE` 등의 연산자를 이용해 인덱스를 검색할 때 사용된다.
    - **일반적으로 애플리케이션의 쿼리가 가장 많이 사용하는 접근 방법인데, rage 접근 방법도 상당히 빠르므로 이 방법만 사용해도 성능이 보장된다.**
    - 또한, 일반적으로 인덱스 레인지 스캔은 const, ref, range 세 가지 접근 방법을 구분 없이 묶어서 지칭한다.

        ```sql
        EXPLAIN
        SELECT * FROM employees WHERE emp_no BETWEEN 10002 AND 10004;
        +----+-------------+-----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
        | id | select_type | table     | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
        +----+-------------+-----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
        |  1 | SIMPLE      | employees | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    3 |   100.00 | Using where |
        +----+-------------+-----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
        ```

10. **`index_merge`**
    - **2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어 낸 후, 그 결과를 병합해서 처리하는 방식이다.**
    - index_merge 접근 방법의 특징
        - 여러 인덱스를 읽어야 하므로 일반적으로 range 접근 방법보다 효율성이 떨어진다.
        - 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge가 적용되지 않는다.
        - index_merge로 처리된 결과는 2개 이상의 집합이 되기 때문에 교집합, 합집합, 또는 중복 제거와 같은 부가적인 작업이 필요하다.

        ```sql
        -- // emp_no는 프라이머리 키를 이용해 조회하고, first_name은 ix_fistname 인덱스를 이용해 조회한 후 두 결과를 병합
        EXPLAIN
        SELECT * FROM employees
        WHERE emp_no BETWEEN 10001 AND 11000
          OR first_name = 'Smith';
        +----+-------------+-----------+------------+-------------+----------------------+----------------------+---------+------+------+----------+------------------------------------------------+
        | id | select_type | table     | partitions | type        | possible_keys        | key                  | key_len | ref  | rows | filtered | Extra                                          |
        +----+-------------+-----------+------------+-------------+----------------------+----------------------+---------+------+------+----------+------------------------------------------------+
        |  1 | SIMPLE      | employees | NULL       | index_merge | PRIMARY,ix_firstname | PRIMARY,ix_firstname | 4,58    | NULL | 1001 |   100.00 | Using union(PRIMARY,ix_firstname); Using where |
        +----+-------------+-----------+------------+-------------+----------------------+----------------------+---------+------+------+----------+------------------------------------------------+
        ```

11. **`index`**
    - **index 접근 방법은 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미한다.**
    - 인덱스 풀 스캔은 풀 테이블 스캔 방식과 비교하는 레코드 건수는 같지만, 일반적으로 인덱스가 데이터 파일 전체보다 작으므로 풀 테이블 스캔보다 빠르다.
    - index 접근 방법은 다음 조건중 1,2를 충족하거나 1,3을 충족하는 쿼리에서 사용된다.

        ① range, const, ref 같은 접근 방법으로 인덱스를 사용하지 못하는 경우  
        ② 인덱스에 포함된 칼럼만으로 처리할 수 있는 쿼리인 경우 (즉, 데이터 파일을 읽지 않아도 되는 경우)  
        ③ 인덱스를 이용해 정렬이나 그루핑 작업이 가능한 경우 (즉, 별도의 정렬 작업을 피할 수 있는 경우)

        ```sql
        EXPLAIN
        SELECT * FROM departments ORDER BY dept_name DESC LIMIT 10;
        ```
        - 위 쿼리는 LIMIT 조건이 있기 때문에 효율적이지만, **LIMIT 조건이 없거나 레코드 건수가 많아지면 상당히 느린 처리르 수행한다.**
12. **`ALL`**
    - **풀 테이블 스캔을 의미하는 접근 방법이다.**
    - 풀 테이블 스캔은 처음부터 끝까지 전부 읽어서 (체크 조건이 존재할 때) 불필요한 레코드를 제거하고 반환한다.
    - **풀 테이블 스캔은 가장 마지막에 선택하는 가장 비효율적인 방법이다.**
    - InnoDB는 풀 테이블 스캔이나 인덱스 풀 스캔과 같은 대량의 I/O를 유발하는 작업을 위해 한꺼번에 많은 페이지를 읽어들이는 “리드 어헤드” 기능을 제공한다.
        - MySQL 서버는 인접한 페이지가 연속해서 읽히면 백그라운드 읽기 스레드에서 최대 64개의 페이지씩 한꺼번에 읽을 수 있다.
        - `innodb_read_ahead_threshold`, `innodb_random_read_ahead` 시스템 변수를 이용해 리드 어헤드 실행을 제어할 수 있다.

      → 쿼리를 튜닝할 때, 무조건 인덱스 풀 스캔이나 테이블 풀 스캔을 제거하는 것이 아니라 쿼리의 성능을 확인해보고 적용해야 한다.


### 3.6 possible_keys 칼럼

- 옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 접근 방법에서 사용되는 인덱스의 목록이다.
- possible_keys 칼럼은 쿼리를 튜닝하는데 크게 도움이 되지 않는다.


### 3.7 key 칼럼

- 최종 선택된 실행 계획에서 사용하는 인덱스를 의미한다.
- 프라이머리 키를 인덱스로 사용하는 경우 PRIMARY로 표시되는데, MySQL 서버에서 프라이머리 키는 별도의 이름을 부여할 수 없고 기본적으로 PRIMARY 라는 이름을 가진다.
- 인덱스를 사용하지 못하면 key 칼럼은 NULL로 표시된다.


### 3.8 key_len 칼럼

- 인덱스에서 몇 바이트까지 사용했는지 알려주는 값이다.
- 다중 칼럼으로 구성된 인덱스에서 어떤 인덱스를 사용했는지 알 수 있다.

    ```sql
    -- // detp_no의 타입이 varchar(4)이고, 메모리 공간을 할당하기 위해 utf8mb4 문자를 고정적으로 4바이트를 잡는다.
    -- // emp_no의 타입은 integer이고, 4바이트를 차지한다.
    EXPLAIN 
    SELECT * 
    FROM dept_emp 
    WHERE dept_no = 'd005' AND emp_no = 10001;
    +----+-------------+----------+------------+-------+---------------------------+---------+---------+-------------+------+----------+-------+
    | id | select_type | table    | partitions | type  | possible_keys             | key     | key_len | ref         | rows | filtered | Extra |
    +----+-------------+----------+------------+-------+---------------------------+---------+---------+-------------+------+----------+-------+
    |  1 | SIMPLE      | dept_emp | NULL       | const | PRIMARY,ix_empno_fromdate | PRIMARY | 20      | const,const |    1 |   100.00 | NULL  |
    +----+-------------+----------+------------+-------+---------------------------+---------+---------+-------------+------+----------+-------+
    ```
    - NULL이 저장될 수 있는 칼럼으로 정의되었다면, 1바이트를 추가로 더 사용한다.


### 3.9 ref 칼럼

- 접근 방법이 ref면 참조 조건(equal 비교 조건)으로 어떤 값이 제공됐는지 보여준다.
    - 상수 → const
    - 다른 테이블의 칼럼 값 → 테이블명과 칼럼명
    - func → 콜레이션 변환 값이나 값 자체의 연산을 거쳐 참조됨을 의미

    ```sql
    EXPLAIN
    SELECT *
    FROM employees e, dept_emp de
    WHERE e.emp_no = (de.emp_no - 1);
    +----+-------------+-------+------------+--------+---------------+---------+---------+------+--------+----------+-------------+
    | id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref  | rows   | filtered | Extra       |
    +----+-------------+-------+------------+--------+---------------+---------+---------+------+--------+----------+-------------+
    |  1 | SIMPLE      | de    | NULL       | ALL    | NULL          | NULL    | NULL    | NULL | 331143 |   100.00 | NULL        |
    |  1 | SIMPLE      | e     | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | func |      1 |   100.00 | Using where |
    +----+-------------+-------+------------+--------+---------------+---------+---------+------+--------+----------+-------------+
    ```
    - 숫자 타입의 칼럼과 문자열 타입의 칼럼을 조인할 때 처럼 MySQL 서버가 내부적으로 값을 변환해야 할 때도 func가 표시된다.


### 3.10 rows 칼럼

- 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여준다.
- 반환하는 레코드의 예측치가 아닌, 쿼리를 처리하기 위해 얼마나 많은 레코드를 읽고 체크해야 하는지를 의미한다.
- 이 값은 각 스토리지 엔진별로 가지고 있는 통계 정보를 참조해 MyQL 옵티마이저가 산출해 낸 예상 값이라서 정확하지는 않다.

    ```sql
    -- // 풀 스캔을 선택하여, 33143건의 레코드를 읽어야 할 것이라고 예측
    EXPLAIN
    SELECT * FROM dept_emp WHERE from_date >= '1985-01-01';
    +----+-------------+----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
    | id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
    +----+-------------+----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
    |  1 | SIMPLE      | dept_emp | NULL       | ALL  | ix_fromdate   | NULL | NULL    | NULL | 331143 |    50.00 | Using where |
    +----+-------------+----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
    
    -- // 레인지 스캔을 선택하여, 292건의 레코드를 읽어야 할 것이라고 예측
    EXPLAIN
    SELECT * FROM dept_emp WHERE from_date >= '2002-07-01';
    +----+-------------+----------+------------+-------+---------------+-------------+---------+------+------+----------+-----------------------+
    | id | select_type | table    | partitions | type  | possible_keys | key         | key_len | ref  | rows | filtered | Extra                 |
    +----+-------------+----------+------------+-------+---------------+-------------+---------+------+------+----------+-----------------------+
    |  1 | SIMPLE      | dept_emp | NULL       | range | ix_fromdate   | ix_fromdate | 3       | NULL |  292 |   100.00 | Using index condition |
    +----+-------------+----------+------------+-------+---------------+-------------+---------+------+------+----------+-----------------------+
    ```


### 3.11 filtered 칼럼

- row 칼럼의 값은 인덱스를 사용하는 조건에만 일치하는 레코드 건수를 예측한 것이다.
- `WHERE` 절에서 인덱스를 사용할 수 있는 조건도 중요하지만 인덱스를 사용하지 못하는 조건에 일치하는 레코드 건수를 파악하는 것도 매우 중요하다.
- filtered 칼럼의 값은 필터링 되어 버려지는 레코드의 비율이 아니라 필터링되고 남은 레코드의 비율을 의미한다.

    ```sql
    -- // employees 테이블에서 인덱스 조건에만 일치하는 레코드는 대략 233건이다.
    -- // 이 중에서 16.64%만 인덱스를 사용하지 못한다. (hire_date 조건에 인덱스를 사용하지 못함)
    EXPLAIN
    SELECT * 
    FROM employees e, salaries s
    WHERE e.first_name = 'Matt'
    	AND e.hire_date BETWEEN '1990-01-01' AND '1991-01-01'
    	AND e.emp_no = s.emp_no
    	AND s.from_date BETWEEN '1990-01-01' AND '1991-01-01'
    	AND s.salary BETWEEN 50000 AND 60000;
    +----+-------------+-------+------------+------+----------------------------------+--------------+---------+-----------------+------+----------+-------------+
    | id | select_type | table | partitions | type | possible_keys                    | key          | key_len | ref             | rows | filtered | Extra       |
    +----+-------------+-------+------------+------+----------------------------------+--------------+---------+-----------------+------+----------+-------------+
    |  1 | SIMPLE      | e     | NULL       | ref  | PRIMARY,ix_hiredate,ix_firstname | ix_firstname | 58      | const           |  233 |    16.64 | Using where |
    |  1 | SIMPLE      | s     | NULL       | ref  | PRIMARY,ix_salary                | PRIMARY      | 4       | testdb.e.emp_no |    9 |     4.77 | Using where |
    +----+-------------+-------+------------+------+----------------------------------+--------------+---------+-----------------+------+----------+-------------+
    ```
    - employees 테이블에서 salaries 테이블로 조인을 수행한 레코드 건수는 대략 39(233 *16.64 )건 정도였다는 것을 알 수 있다.
- filtered 칼럼에 표시되는 값이 얼마나 정확히 예측 될 수 있느냐에 따라 조인의 성능이 달라진다. 이를 위해 MySQL8.0에서 히스토그램이 도입된 것이다.


### 3.12 Extra 칼럼

- Extra 칼럼은 쿼리의 실행 계획에서 성능에 관련된 중요한 내용이 표시된다.
- Extra 칼럼에는 고정된 몇 개의 문장이 표시되는데, 일반적으로 2~3개씩 함께 표시된다.

1. **const row not found**
    - const 접근 방법으로 테이블을 읽었지만 실제로 해당 테이블에 레코드가 1건도 존재하지 않을때 표시된다.
2. **Deleting all rows**
    - 테이블의 모든 레코드를 삭제하는 핸들러 기능(API)이 호출된 것을 의미한다.
    - MySQL 8.0 버전에서는 InnoDB 스토리지 엔진과 MyISAM 엔진 모두에서 더 이상 실행 계획에 표시되지 않는다.
    - 테이블의 모든 레코드를 삭제하고자 한다면 WHERE 조건절이 없는 DELETE 보다 `TRUNCATE TABLE` 명령을 사용할 것을 권장한다.
3. **Distinct**
    - DISTINCT 키워드를 사용할 때 표시된다.
    - 조인에서 DISTINCT를 사용하는 경우 조인하지 않아도 되는 항목은 무시하고 꼭 필요한 것만 찾아서 조인하고, 테이블에서 읽을 때도 꼭 필요한 레코드만 읽는다.

        ```sql
        EXPLAIN
        SELECT DISTINCT d.dept_no
        FROM departments d, dept_emp de WHERE de.dept_no = d.dept_no;
        +----+-------------+-------+------------+-------+---------------------+-------------+---------+------------------+-------+----------+------------------------------+
        | id | select_type | table | partitions | type  | possible_keys       | key         | key_len | ref              | rows  | filtered | Extra                        |
        +----+-------------+-------+------------+-------+---------------------+-------------+---------+------------------+-------+----------+------------------------------+
        |  1 | SIMPLE      | d     | NULL       | index | PRIMARY,ux_deptname | ux_deptname | 162     | NULL             |     9 |   100.00 | Using index; Using temporary |
        |  1 | SIMPLE      | de    | NULL       | ref   | PRIMARY             | PRIMARY     | 16      | testdb.d.dept_no | 41392 |   100.00 | Using index; Distinct        |
        +----+-------------+-------+------------+-------+---------------------+-------------+---------+------------------+-------+----------+------------------------------+
        ```
4. **FirstMatch**
    - 세미 조인의 여러 최적화 중에서 FirstMatch가 사용된 경우 표시된다.

        ```sql
        EXPLAIN 
        SELECT *
        FROM employees e
        WHERE e.first_name = 'Matt'
          AND e.emp_no IN (
              SELECT t.emp_no FROM titles t
              WHERE t.from_date BETWEEN '1995-01-01' AND '1995-01-30'
        );
        +----+-------------+-------+------------+------+----------------------+--------------+---------+-----------------+------+----------+-----------------------------------------+
        | id | select_type | table | partitions | type | possible_keys        | key          | key_len | ref             | rows | filtered | Extra                                   |
        +----+-------------+-------+------------+------+----------------------+--------------+---------+-----------------+------+----------+-----------------------------------------+
        |  1 | SIMPLE      | e     | NULL       | ref  | PRIMARY,ix_firstname | ix_firstname | 58      | const           |  233 |   100.00 | NULL                                    |
        |  1 | SIMPLE      | t     | NULL       | ref  | PRIMARY              | PRIMARY      | 4       | testdb.e.emp_no |    1 |    11.11 | Using where; Using index; FirstMatch(e) |
        +----+-------------+-------+------------+------+----------------------+--------------+---------+-----------------+------+----------+-----------------------------------------+
        ```

5. **Full scan on NULL key**
    - `col1 IN (SELECT col2 FROM…)`과 같은 쿼리에서 자주 발생할 수 있는데, 비교 조건에서 NULL이 포함되는 경우에 테이블 풀 스캔을 사용할 것이라는 의미이다.

        ```sql
        EXPLAIN
        SELECT d1.dept_no,
            NULL IN (SELECT d2.dept_name FROM departments d2)
        FROM departments d1;
        +----+-------------+-------+------------+----------------+---------------+-------------+---------+------+------+----------+-------------------------------------------------+
        | id | select_type | table | partitions | type           | possible_keys | key         | key_len | ref  | rows | filtered | Extra                                           |
        +----+-------------+-------+------------+----------------+---------------+-------------+---------+------+------+----------+-------------------------------------------------+
        |  1 | PRIMARY     | d1    | NULL       | index          | NULL          | ux_deptname | 162     | NULL |    9 |   100.00 | Using index                                     |
        |  2 | SUBQUERY    | d2    | NULL       | index_subquery | ux_deptname   | ux_deptname | 162     | func |    1 |   100.00 | Using where; Using index; Full scan on NULL key |
        +----+-------------+-------+------------+----------------+---------------+-------------+---------+------+------+----------+-------------------------------------------------+
        ```
    - 비교 칼럼이 NOT NULL 조건이라면 테이블 풀 스캔이 일어나지 않으며, NOT NULL로 정의되지 않았지만 NULL 비교 규칙을 무시해도 된다면 명시적으로 옵티마이저에게 알려주면 된다.

        ```sql
        EXPLAIN ANALYZE
        SELECT d1.dept_no
        FROM dept_emp d1
        WHERE d1.dept_no IS NOT NULL
            AND d1.dept_no IN (SELECT d2.dept_no FROM departments d2);
        +----+-------------+-------+------------+-------+---------------+-------------+---------+-------------------+-------+----------+-------------+
        | id | select_type | table | partitions | type  | possible_keys | key         | key_len | ref               | rows  | filtered | Extra       |
        +----+-------------+-------+------------+-------+---------------+-------------+---------+-------------------+-------+----------+-------------+
        |  1 | SIMPLE      | d2    | NULL       | index | PRIMARY       | ux_deptname | 162     | NULL              |     9 |   100.00 | Using index |
        |  1 | SIMPLE      | d1    | NULL       | ref   | PRIMARY       | PRIMARY     | 16      | testdb.d2.dept_no | 41392 |   100.00 | Using index |
        +----+-------------+-------+------------+-------+---------------+-------------+---------+-------------------+-------+----------+-------------+
        ```
        - dept_no가 NULL이면 AND 조건에 의해 후속 조건을 실행하지 않는다.
    - IN 이나 NOT IN 연산자의 왼쪽 값이 NULL인 레코드가 있고, 서브쿼리에 개별 WHERE 조건이 있다면 상당한 성능 문제가 발생할 수도 있다.

6. **Impossible HAVING**
    - HAVING 절의 조건을 만족하는 레코드가 없을 때 표시된다.
    - Impossible HAVING이 표시되는 경우, 쿼리를 잘못 작성했을 수 있으므로 다시 점검하는 것이 좋다.

        ```sql
        EXPLAIN
        SELECT e.emp_no, COUNT(*) AS cnt
        FROM employees e
        WHERE e.emp_no = 10001
        GROUP BY e.emp_no
        HAVING e.emp_no IS NULL;
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------+
        | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra             |
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------+
        |  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Impossible HAVING |
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------+
        ```

7. **Impossible WHERE**
    - Impossible HAVING과 비슷하며, WHERE 조건이 항상 FALSE가 될 수 밖에 없는 경우 표시된다.

        ```sql
        EXPLAIN
        SELECT * FROM employees e
        WHERE e.emp_no IS NULL;
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+
        | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra            |
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+
        |  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Impossible WHERE |
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+
        ```

8. **LooseScan**
    - 세미 조인 최적화 중에서 LooseScan 최적화 전략이 사용되는 경우 표시된다.

        ```sql
        EXPLAIN
        SELECT * FROM departments d 
        WHERE d.dept_no IN (
            SELECT de.dept_no FROM dept_emp de
        );
        +----+-------------+-------+------------+-------+---------------+---------+---------+------+--------+----------+--------------------------------------------+
        | id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows   | filtered | Extra                                      |
        +----+-------------+-------+------------+-------+---------------+---------+---------+------+--------+----------+--------------------------------------------+
        |  1 | SIMPLE      | de    | NULL       | index | PRIMARY       | PRIMARY | 20      | NULL | 331143 |     0.00 | Using index; LooseScan                     |
        |  1 | SIMPLE      | d     | NULL       | ALL   | PRIMARY       | NULL    | NULL    | NULL |      9 |    11.11 | Using where; Using join buffer (hash join) |
        +----+-------------+-------+------------+-------+---------------+---------+---------+------+--------+----------+--------------------------------------------+
        ```

9. **No matching min/max row**
    - MIN()이나 MAX() 와 같은 집합 함수가 있는 쿼리의 조건절에 일치하는 레코드가 한 건도 없을 때 표시된다.

        ```sql
        EXPLAIN 
        SELECT MIN(dept_no), MAX(dept_no)
        FROM dept_emp WHERE dept_no = '';
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+
        | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                   |
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+
        |  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No matching min/max row |
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+
        ```

10. **No matching row in const table**
    - 조인에 사용된 테이블에서 const 방법으로 접근할 때 일치하는 레코드가 없으면 표시된다.

        ```sql
        EXPLAIN
        SELECT *
        FROM dept_emp de,
            (SELECT emp_no FROM employees WHERE emp_no = 0) tb1
        WHERE tb1.emp_no = de.emp_no AND de.dept_no = 'd005';
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+
        | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                          |
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+
        |  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | no matching row in const table |
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+
        ```

11. **No matching rows after partition pruning**
    - 파티션에서 UPDATE하거나 DELETE할 대상 레코드가 없을 때 표시된다.
    - 이 메시지는 단순히 삭제할 레코드가 없음을 의미하는 것이 아니라 대상 파티션이 없다는 것을 의미한다.

        ```sql
        CREATE TABLE employees_parted (
                 emp_no int NOT NULL,
                 birth_date DATE NOT NULL,
                 first_name VARCHAR(14) NOT NULL,
                 last_name VARCHAR(16) NOT NULL,
                 gender ENUM('M','F') NOT NULL,
                 hire_date DATE NOT NULL,
                 PRIMARY KEY (emp_no, hire_date)
         ) PARTITION BY RANGE COLUMNS(hire_date)
         (PARTITION p1986_1990 VALUES LESS THAN ('1991-01-01'),
          PARTITION p1991_1995 VALUES LESS THAN ('1996-01-01'),
          PARTITION p1996_2000 VALUES LESS THAN ('2001-01-01'),
          PARTITION p2001_2005 VALUES LESS THAN ('2006-01-01'));
        
        INSERT INTO employees_parted SELECT * FROM employees;
        
        EXPLAIN DELETE FROM employees_parted WHERE hire_date >= '2020-01-01';
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------------------+
        | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                    |
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------------------+
        |  1 | DELETE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No matching rows after partition pruning |
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------------------+
        ```

12. **No tables used**
    - FROM 절이 없는 쿼리 문장이나 FROM DUAL 형태의 실행 계획에서 표시된다.
    - MySQL은 다른 DBMS와 달리 FROM 절이 없는 쿼리도 허용한다.

        ```sql
        EXPLAIN SELECT 1;
        EXPLAIN SELECT 1 FROM DUAL;
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
        | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
        |  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
        ```

13. **Not exists**
    - 아우터 조인을 이용해 안티-조인을 수행하는 쿼리에서 표시된다.
    - A 테이블에는 존재하지만 B 테이블에는 없는 값을 조회하는 쿼리를 사용할 때 주로 `NOT IN(subquery)` 또는 `NOT EXISTS` 연산자를 사용하는데 이러한 조인을 안티-조인이라고 한다.
    - 안티 조인에서 레코드가 많을 때는 아우터 조인을 이용하면 빠른 성능을 낼 수 있다.
        - 아래의 쿼리에서 ON 절이 아닌 WHERE 절에 아우터 테이블(departments)의 dept_no 칼럼이 NULL인 레코드만 체크해서 가져온다.
        - 즉, departments 테이블에 조인 조건에 일치하는 레코드가 여러 건이 있어도 딱 1건만 조회해보고 처리를 완료하는 최적화를 의미한다.

        ```sql
        EXPLAIN
        SELECT *
        FROM dept_emp de
          LEFT JOIN departments d ON de.dept_no = d.dept_no
        WHERE d.dept_no IS NULL;
        +----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+--------------------------------------------------------+
        | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra                                                  |
        +----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+--------------------------------------------------------+
        |  1 | SIMPLE      | de    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 331143 |   100.00 | NULL                                                   |
        |  1 | SIMPLE      | d     | NULL       | ALL  | PRIMARY       | NULL | NULL    | NULL |      9 |    11.11 | Using where; Not exists; Using join buffer (hash join) |
        +----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+--------------------------------------------------------+
        ```

14. **Plan isn’t ready yet**
    - MySQL 8.0 버전에서는 다른 커넥션에서 실행 중인 쿼리의 실행 계획을 살펴볼 수 있다.
    - `EXPLAIN FOR CONNECTION` 명령을 실행했을 때 해당 커넥션에서 아직 쿼리의 실행 계획을 수립하지 못한 상태에서 표시된다.

        ```sql
        SHOW PROCESSLIST;
        +----+-----------------+-----------+--------+---------+--------+------------------------+------------------+
        | Id | User            | Host      | db     | Command | Time   | State                  | Info             |
        +----+-----------------+-----------+--------+---------+--------+------------------------+------------------+
        |  5 | event_scheduler | localhost | NULL   | Daemon  | 919605 | Waiting on empty queue | NULL             |
        | 11 | chloe           | localhost | testdb | Query   |      0 | starting               | SHOW PROCESSLIST |
        +----+-----------------+-----------+--------+---------+--------+------------------------+------------------+
        
        SELECT * FROM employees WHERE SLEEP(1);
        
        -- // 다른 커넥션에서 확인
        EXPLAIN FOR CONNECTION 11;
        +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
        | id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
        +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
        |  1 | SIMPLE      | employees | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 300695 |   100.00 | Using where |
        +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
        ```

15. **Range checked for each record(index map:N)**
    - 조인 쿼리의 드리븐 테이블을 읽을 때, 레코드마다 인덱스 레인지 스캔을 체크한다는 의미이다.
    - 두 개의 테이블을 조인하는 쿼리에서 드리븐 테이블을 읽을 때, 인덱스 레인즈 스캔과 풀 테이블 스캔 중에서 어느 것이 효율적일지 판단할 수 없다.

        ```sql
        EXPLAIN
        SELECT * FROM employees e1, employees e2
        WHERE e2.emp_no >= e1.emp_no;
        +----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+------------------------------------------------+
        | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra                                          |
        +----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+------------------------------------------------+
        |  1 | SIMPLE      | e1    | NULL       | ALL  | PRIMARY       | NULL | NULL    | NULL | 300695 |   100.00 | NULL                                           |
        |  1 | SIMPLE      | e2    | NULL       | ALL  | PRIMARY       | NULL | NULL    | NULL | 300695 |    33.33 | Range checked for each record (index map: 0x1) |
        +----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+------------------------------------------------+
        ```
        - 사번에 1억 번까지 있을 때, emp_no가 작을 때는 e2 테이블을 풀 테이블 스캔으로 접근하고, emp_no가 큰 값일 때는 e2 테이블을 인덱스 레인지 스캔으로 접근하는 형태를 수행하는 것이 최적의 조인 방법이다.
        - `(index map: 0x1)`은 후보 인덱스 순번을 나타낸다.
    - 후보 인덱스 순번 (index map:N)
        - index map은 16진수로 표시되는데, 해석을 위해 이진수로 변환한다.
        - 예를 들어, (index map:0x19)인 경우 이진수로 바꾸면 25가 되고, 이진로 표기법으로는 11001이다.
        - 1의 자리부터 첫 번째 인덱스이고, 인덱스는 2^5 자리가 마지막 인덱스를 뜻한다.
        - 1이면 해당 인덱스를 사용했음을 의미하고, 0이면 인덱스를 사용하지 않았음을 의미한다.
        - 후보 인덱스 가운데 어떤 인덱스를 사용할지 결정하게 되는데, 실제 어떤 인덱스가 사용됐는지는 알 수 없다.

16. **Recursive**
    - MySQL 8.0 버전부터 CTE(Common Table Expression)를 이용해 재귀 쿼리를 작성할 수 있게 되었는데, CTE를 이용한 재귀 쿼리의 실행 계획에 표시된다.

        ```sql
        EXPLAIN
        WITH RECURSIVE cte(n) AS (
            SELECT 1
                UNION ALL
            SELECT n + 1 FROM cte WHERE n < 5
        ) SELECT * FROM cte;
        +----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+------------------------+
        | id | select_type | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                  |
        +----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+------------------------+
        |  1 | PRIMARY     | <derived2> | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |   100.00 | NULL                   |
        |  2 | DERIVED     | NULL       | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used         |
        |  3 | UNION       | cte        | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |    50.00 | Recursive; Using where |
        +----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+------------------------+
        ```

17. **Rematerialize**
    - MySQL 8.0 버전부터 래터럴 조인 기능이 추가되었고, 래터럴 조인이 사용되어 매번 임시 테이블이 생성됨을 의미한다.
    - 래터럴 조인은 선행 테이블의 레코드 별로 서브쿼리를 실행해서 그 결과를 임시 테이블에 저장하는데, 이 과정을 Rematerializing이라고 한다.

        ```sql
        EXPLAIN
        SELECT * FROM employees e
          LEFT JOIN LATERAL (SELECT *
                             FROM salaries s
                             WHERE s.emp_no = e.emp_no
                             ORDER BY s.from_date DESC LIMIT 2) s2 ON s2.emp_no = e.emp_no
        WHERE e.first_name = 'Matt';
        +----+-------------------+------------+------------+------+---------------+--------------+---------+-----------------+------+----------+----------------------------+
        | id | select_type       | table      | partitions | type | possible_keys | key          | key_len | ref             | rows | filtered | Extra                      |
        +----+-------------------+------------+------------+------+---------------+--------------+---------+-----------------+------+----------+----------------------------+
        |  1 | PRIMARY           | e          | NULL       | ref  | ix_firstname  | ix_firstname | 58      | const           |  233 |   100.00 | Rematerialize (<derived2>) |
        |  1 | PRIMARY           | <derived2> | NULL       | ref  | <auto_key0>   | <auto_key0>  | 4       | testdb.e.emp_no |    2 |   100.00 | NULL                       |
        |  2 | DEPENDENT DERIVED | s          | NULL       | ref  | PRIMARY       | PRIMARY      | 4       | testdb.e.emp_no |    9 |   100.00 | Using filesort             |
        +----+-------------------+------------+------------+------+---------------+--------------+---------+-----------------+------+----------+----------------------------+
        ```
        - derived2 임시 테이블은 employees 테이블의 레코드마다 새로 내부 임시 테이블이 생성된다.

18. **Select tables optimized away**
    - 인덱스를 오름차순 또는 내림차순으로 1건만 읽는 형태의 최적화가 적용되면 표시된다.
        - MIN() 또는 MAX()만 SELECT 절에 사용되거나 GROUP BY로 MIN() 또는 MAX()를 조회하는 쿼리

        ```sql
        --// (emp_no, from_date)로 인덱스가 생성되어 있음
        EXPLAIN
        SELECT MAX(from_date), MIN(from_date) FROM salaries WHERE emp_no = 10002;
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+
        | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                        |
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+
        |  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Select tables optimized away |
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+
        ```

19. **Start temporary, End temporary**
    - 세미 조인 최적화 중에서 Duplicate Weed-out 최적화 전략이 사용되면 표시된다.
    - Duplicate Weed-out 최적화 전략은 **불필요한 중복 건을 제거하기 위해서 내부 임시테이블을 사용**한다.
    - 이때, 내부 임시 테이블에 저장되는 테이블을 식별할 수 있게 조인의 첫 번째 테이블에 “Start temporary”가 표시되고, 조인이 끝나는 부분에 “End temporary”가 표시된다.

        ```sql
        EXPLAIN
        SELECT * FROM employees e
        WHERE e.emp_no IN (SELECT s.emp_no FROM salaries s WHERE s.salary > 200000);
        +----+-------------+-------+------------+--------+-------------------+-----------+---------+-----------------+------+----------+-------------------------------------------+
        | id | select_type | table | partitions | type   | possible_keys     | key       | key_len | ref             | rows | filtered | Extra                                     |
        +----+-------------+-------+------------+--------+-------------------+-----------+---------+-----------------+------+----------+-------------------------------------------+
        |  1 | SIMPLE      | s     | NULL       | range  | PRIMARY,ix_salary | ix_salary | 4       | NULL            |    1 |   100.00 | Using where; Using index; Start temporary |
        |  1 | SIMPLE      | e     | NULL       | eq_ref | PRIMARY           | PRIMARY   | 4       | testdb.s.emp_no |    1 |   100.00 | End temporary                             |
        +----+-------------+-------+------------+--------+-------------------+-----------+---------+-----------------+------+----------+-------------------------------------------+
        ```

20. **unique row not found**
    - 두 개의 테이블이 각각 유니크 칼럼으로 아우터 조인을 수행하는 쿼리에서 아우터 테이블에 일치하는 레코드가 존재하지 않을 때 표시된다.

        ```sql
        CREATE TABLE tb_test1(fdpk INT, PRIMARY KEY(fdpk));
        CREATE TABLE tb_test2(fdpk INT, PRIMARY KEY(fdpk));
        
        INSERT INTO tb_test1 VALUES (1), (2);
        INSERT INTO tb_test2 VALUES (1);
        
        EXPLAIN
        SELECT t1.fdpk
        FROM tb_test1 t1
          LEFT JOIN tb_test2 t2 ON t2.fdpk = t1.fdpk WHERE t1.fdpk = 2;
        +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+----------------------+
        | id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra                |
        +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+----------------------+
        |  1 | SIMPLE      | t1    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | Using index          |
        |  1 | SIMPLE      | t2    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    0 |     0.00 | unique row not found |
        +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+----------------------+
        ```

21. **Using filesort**
    - `ORDER BY` 처리가 인덱스를 사용하지 못할 때만 표시된다.
    - 정렬에 인덱스를 사용하지 못할 때는 MySQL 서버가 조회된 레코드를 정렬용 메모리 버퍼(소트 버퍼)에 복사해서 퀵 소트 또는 힙 소트 알고리즘을 이용해 정렬을 수행하게 된다는 의미이다.

        ```sql
        EXPLAIN
        SELECT * FROM employees
        ORDER BY last_name DESC;
        +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
        | id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra          |
        +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
        |  1 | SIMPLE      | employees | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 300596 |   100.00 | Using filesort |
        +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
        ```
    **→ “Using filesort”가 출력되는 쿼리는 많은 부하를 일으키므로 가능하다면 쿼리를 튜닝하거나 인덱스를 생성하는 것이 좋다.**

22. **Using index(커버링 인덱스)**
    - 데이터 파일을 전혀 읽지 않고 인덱스만 읽어서 쿼리를 모두 처리할 수 있을 때 표시된다.
    - 인덱스를 이용해 처리하는 쿼리에서 가장 큰 부하를 차지하는 부분은 인덱스 검색에서 일치하는 키 값들의 레코드를 읽기 위해 데이터 파일을 검색하는 작업이다.
    - 인덱스만으로 처리되는 방식을 커버링 인덱스라고 한다.

        ```sql
        --// 옵티마이저가 인덱스를 사용하는 것보다 풀 테이블 스캔으로 처리하는 것이 효율적이라고 판단
        --// ix_firstname 인덱스를 사용하면 일치하는 레코드 5만여 건을 검색하고, birth_date 칼럼의 값을 읽기 위해 각 레코드에 저장된 데이터 페이지를 5만여 번 읽어야 함
        EXPLAIN
        SELECT first_name, birth_date
        FROM employees
        WHERE first_name BETWEEN 'Babette' AND 'Gad';
        +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
        | id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
        +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
        |  1 | SIMPLE      | employees | NULL       | ALL  | ix_firstname  | NULL | NULL    | NULL | 300596 |    31.21 | Using where |
        +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
        
        -- // 풀 테이블 스캔이 아닌 인덱스 레인지 스캔으로 처리
        -- // 필요한 칼럼이 모두 인덱스에 있으므로, 데이터 파일을 읽어올 필요 없음
        -- // 디스크에서 30~40개의 페이지만 읽으면 되기 때문에 매우 빠른 속도로 처리됨
        EXPLAIN
        SELECT first_name
        FROM employees
        WHERE first_name BETWEEN 'Babette' AND 'Gad';
        +----+-------------+-----------+------------+-------+---------------+--------------+---------+------+-------+----------+--------------------------+
        | id | select_type | table     | partitions | type  | possible_keys | key          | key_len | ref  | rows  | filtered | Extra                    |
        +----+-------------+-----------+------------+-------+---------------+--------------+---------+------+-------+----------+--------------------------+
        |  1 | SIMPLE      | employees | NULL       | range | ix_firstname  | ix_firstname | 58      | NULL | 93802 |   100.00 | Using where; Using index |
        +----+-------------+-----------+------------+-------+---------------+--------------+---------+------+-------+----------+--------------------------+
        ```
    - 커버링 인덱스로 처리할 때와 그렇지 못할 때의 성능 차이는 매우 크다.
    - 하지만 커버링 인덱스로 처리하려고 인덱스에 많은 칼럼을 추가하면 인덱스의 크기가 커져서 메모리 낭비가 심해지고, 레코드를 저장하거나 변경하는 작업이 매우 느려질 수 있다.
    - **실행 계획에서 Extra 칼럼에 표시되는 “Using index”와 type 칼럼에 표시되는 “index”는 성능상 반대되는 개념이라서 반드시 구분해서 이해해야 한다.**

23. **Using index condition**
    - 옵티마이저가 인덱스 컨디션 푸시 다운 최적화를 사용하면 표시된다.

        ```sql
        ALTER TABLE employees ADD INDEX ix_lastname_firstname (last_name, first_name);
        
        EXPLAIN
        SELECT * 
        FROM employees 
        WHERE last_name = 'Action' AND first_name LIKE '%sal';
        +----+-------------+-----------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+
        | id | select_type | table     | partitions | type | possible_keys         | key                   | key_len | ref   | rows | filtered | Extra                 |
        +----+-------------+-----------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+
        |  1 | SIMPLE      | employees | NULL       | ref  | ix_lastname_firstname | ix_lastname_firstname | 66      | const |    1 |    11.11 | Using index condition |
        +----+-------------+-----------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+
        ```

24. **Using index for group-by**
    - GROUP BY 처리가 인덱스를 이용할 때 표시된다.
    - GROUP BY 처리에 인덱스를 이용하면 레코드의 정렬이 필요하지 않고 인덱스의 필요한 부분만 읽으면 되기 때문에 상당히 효율적이고 빠르게 처리된다.
    
    1. 타이트 인덱스 스캔(인덱스 스캔)을 통한 GROUP BY 처리
        - AVG(), SUM(), COUNT() 처럼 조회하려는 값이 모든 인덱스를 다 읽어야 할 때는 필요한 레코드만 듬덩듬성 읽을 수가 없다.
        - 실행 계획에 “Using index for group-by”가 표시되지 않는다.

            ```sql
            EXPLAIN
            SELECT first_name, COUNT(*) AS counter
            FROM employees 
            GROUP BY first_name;
            +----+-------------+-----------+------------+-------+------------------------------------+--------------+---------+------+--------+----------+-------------+
            | id | select_type | table     | partitions | type  | possible_keys                      | key          | key_len | ref  | rows   | filtered | Extra       |
            +----+-------------+-----------+------------+-------+------------------------------------+--------------+---------+------+--------+----------+-------------+
            |  1 | SIMPLE      | employees | NULL       | index | ix_firstname,ix_lastname_firstname | ix_firstname | 58      | NULL | 300596 |   100.00 | Using index |
            +----+-------------+-----------+------------+-------+------------------------------------+--------------+---------+------+--------+----------+-------------+
            ```

    2. 루스 인덱스 스캔을 통한 GROUP BY 처리
        - GROUP BY 처리 시 인덱스를 등성등성하게 필요한 부분만 읽는다.
        - 단일 칼럼으로 구성된 인덱스에서는 그루핑 칼럼 말고는 아무것도 조회하지 않아야 루스 인덱스 스캔을 사용할 수 있다.
        - 다중 칼럼으로 구성된 인덱스에서는 GROUP BY 절이 인덱스를 사용할 수 있어야 하고, MIN(), MAX() 같이 조회하는 값이 첫 번째 또는 마지막 레코드만 읽어도 되는 쿼리에서 루스 인덱스 스캔을 사용할 수 있다.

            ```sql
            EXPLAIN
            SELECT emp_no, MIN(from_date) AS first_changed_date, MAX(from_date) AS last_changed_date
            FROM salaries
            GROUP BY emp_no;
            +----+-------------+----------+------------+-------+-------------------+---------+---------+------+--------+----------+--------------------------+
            | id | select_type | table    | partitions | type  | possible_keys     | key     | key_len | ref  | rows   | filtered | Extra                    |
            +----+-------------+----------+------------+-------+-------------------+---------+---------+------+--------+----------+--------------------------+
            |  1 | SIMPLE      | salaries | NULL       | range | PRIMARY,ix_salary | PRIMARY | 4       | NULL | 295695 |   100.00 | Using index for group-by |
            +----+-------------+----------+------------+-------+-------------------+---------+---------+------+--------+----------+--------------------------+
            ```

        - **GROUP BY에서 인덱스를 사용하기 위한 요건**
            - WHERE 조건이 없는 경우
                - GROUP BY 절의 칼럼과 SELECT로 가져오는 칼럼이 루스 인덱스 스캔을 사용할 수 있는 조건만 만족하면 된다.
            - WHERE 조건절이 있지만 검색을 위해 인덱스를 사용하지 못하는 경우
                - 먼저 GROUP BY를 위해 인덱스를 읽은 후, WHERE 조건의 비교를 위해 데이터 레코드를 읽어야 한다. → (타이트 )인덱스 스캔을 통해 처리
            - WHERE 절의 조건이 있고, 검색을 위해 인덱스를 사용하는 경우
                - WHERE 절의 조건과 GROUP BY 처리가 똑같은 인덱스를 공통으로 사용할 수 있을 때만 루스 인덱스 스캔을 사용할 수 있음
                - WHERE 절에 의해 검색된 레코드 건수가 적으면 루스 인덱스 스캔을 사용하지 않을 수도 있음

                ```sql
                EXPLAIN
                SELECT emp_no, MIN(from_date) AS first_changed_date, MAX(from_date) AS last_changed_date
                FROM salaries
                WHERE emp_no BETWEEN 10001 AND 10099
                GROUP BY emp_no;
                +----+-------------+----------+------------+-------+-------------------+---------+---------+------+------+----------+--------------------------+
                | id | select_type | table    | partitions | type  | possible_keys     | key     | key_len | ref  | rows | filtered | Extra                    |
                +----+-------------+----------+------------+-------+-------------------+---------+---------+------+------+----------+--------------------------+
                |  1 | SIMPLE      | salaries | NULL       | range | PRIMARY,ix_salary | PRIMARY | 4       | NULL |  984 |   100.00 | Using where; Using index |
                +----+-------------+----------+------------+-------+-------------------+---------+---------+------+------+----------+--------------------------+
                ```

25. **Using index for skip scan**
    - 옵티마이저가 인덱스 스킵 스캔 최적화를 사용하면 표시된다.

        ```sql
        ALTER TABLE employees ADD INDEX ix_gender_birthdate (gender, birth_date);
        
        EXPLAIN
        SELECT gender, birth_date
        FROM employees
        WHERE birth_date >= '1965-02-01';
        +----+-------------+-----------+------------+-------+---------------------+---------------------+---------+------+--------+----------+----------------------------------------+
        | id | select_type | table     | partitions | type  | possible_keys       | key                 | key_len | ref  | rows   | filtered | Extra                                  |
        +----+-------------+-----------+------------+-------+---------------------+---------------------+---------+------+--------+----------+----------------------------------------+
        |  1 | SIMPLE      | employees | NULL       | range | ix_gender_birthdate | ix_gender_birthdate | 4       | NULL | 100188 |   100.00 | Using where; Using index for skip scan |
        +----+-------------+-----------+------------+-------+---------------------+---------------------+---------+------+--------+----------+----------------------------------------+
        ```

26. **Using join buffer(Block Nested Loop), Using join buffer(Batched Key Access), Using join buffer(hash join)**
    - 조인 버퍼가 사용되는 실행 계획에 표시된.
    - **조인에 필요한 인덱스는 조인에서 뒤에 읽는 테이블의 칼럼에만 필요하다. 뒤에 읽는 테이블(드리븐 테이블)은 검색 위주로 사용되기 때문에 인덱스가 없으면 성능에 미치는 영향이 매우 크기 때문이다.**
    - 드리븐 테이블에 검색을 위한 적절한 인덱스가 없다면 MySQL 서버는 블록 네스티드 루프 조인이나 해시 조인을 사용한다. → 조인 버퍼 사용
    - 조인 조건이 없는 카테시안 조인을 수행하는 쿼리도 항상 조인 버퍼를 사용한다.

        ```sql
        EXPLAIN
        SELECT * FROM dept_emp de, employees e
        WHERE de.from_date > '2005-01-01' AND e.emp_no < 10904;
        +----+-------------+-------+------------+-------+---------------+-------------+---------+------+------+----------+--------------------------------------------+
        | id | select_type | table | partitions | type  | possible_keys | key         | key_len | ref  | rows | filtered | Extra                                      |
        +----+-------------+-------+------------+-------+---------------+-------------+---------+------+------+----------+--------------------------------------------+
        |  1 | SIMPLE      | de    | NULL       | range | ix_fromdate   | ix_fromdate | 3       | NULL |    1 |   100.00 | Using index condition                      |
        |  1 | SIMPLE      | e     | NULL       | range | PRIMARY       | PRIMARY     | 4       | NULL |  903 |   100.00 | Using where; Using join buffer (hash join) |
        +----+-------------+-------+------------+-------+---------------+-------------+---------+------+------+----------+--------------------------------------------+
        ```

27. **Using MRR**
    - MySQL 엔진은 실행 계획을 수립하고 그 실행 계획에 맞게 스토리지 엔진의 API를 호출해서 쿼리를 처리한다.
    - 이러한 이유로 아무리 많은 레코드를 읽더라도 스토리지 엔진은 MySQL 엔진이 넘겨주는 키 값을 기준으로 레코드를 한 건 한 건 읽어서 반환하는 방식으로 작동한다는 한계점이 있다.
    - MRR 최적화는 MySQL 엔진은 여러 개의 키 값을 한 번에 스토리지 엔진으로 전달하고, 스토리지 엔진은 넘겨 받은 키 값들을 정렬해서 최소한의 페이지 접근만으로 필요한 레코드를 읽을 수 있게 최적화 한다.

28. **Using sort_union(…), Using union(…), Using intersect(…)**
    - 쿼리가 index merge 접근 방법으로 실행되는 경우에는 2개 이상의 인덱스가 동시에 사용될 수 있는데, 이때 Extra 칼럼을 보면 두 인덱스의 결과를 어떻게 병합했는지 확인할 수 있다.
    - index merge 병합 방벙별 Extra 칼럼 표시값
        - `Using intersect(...)`: 인덱스를 사용할 수 있는 조건이 AND로 연결된 경우, 각 처리 결과의 교집합을 의미
        - `Using union(...)`: 인덱스를 사용할 수 있는 조건이 OR로 연결된 경우, 각 처리 결과의 합집합을 의미
        - `Using sort_union(...)`: Using union과 같은 작업을 수행하지만 Using union으로 처리될 수 없는 경우에 사용

      → Using union은 대체로 동등 비교 처럼 일치하는 레코드 건수가 많지 않은 경우에 사용되고, Using sort_union은 범위 조건과 같이 상대적으로 많은 레코드에서 프라이머리 키만 먼저 읽어서 정렬하고 병합한 뒤에 레코드를 읽는 방식으로 사용된다.

29. **Using temporary**
    - 쿼리 수행을 위해 임시 테이블이 사용된 경우에 표시된다.
    - 임시 테이블은 메모리상에 생성될 수도 있고 디스크상에 생성될 수도 있는데, 실행 계획만으로는 판단할 수 없다.

        ```sql
        EXPLAIN
        SELECT gender 
        FROM employees 
        GROUP BY gender
        ORDER BY MIN(emp_no);
        +----+-------------+-----------+------------+-------+---------------------+---------------------+---------+------+--------+----------+----------------------------------------------+
        | id | select_type | table     | partitions | type  | possible_keys       | key                 | key_len | ref  | rows   | filtered | Extra                                        |
        +----+-------------+-----------+------------+-------+---------------------+---------------------+---------+------+--------+----------+----------------------------------------------+
        |  1 | SIMPLE      | employees | NULL       | index | ix_gender_birthdate | ix_gender_birthdate | 4       | NULL | 300695 |   100.00 | Using index; Using temporary; Using filesort |
        +----+-------------+-----------+------------+-------+---------------------+---------------------+---------+------+--------+----------+----------------------------------------------+
        ```

    - Extra 칼럼에 “Using temporary”가 표시되지 않더라도 내부적으로는 임시 테이블을 사용할 때도 많다.
    - **메모리나 디스크에 임시 테이블을 생성하는 대표적인 쿼리**
        - `FROM` 절에 사용된 서브쿼리는 무조건 임시 테이블을 사용한다. (파생 테이블)
        - `COUNT(DISTINCT column1)`를 포함하는 쿼리가 인덱스를 사용할 수 없는 경우에 임시 테이블이 만들어진다.
        - `UNION` 이나 `UNION DISTINCT`가 사용된 쿼리도 항상 임시 테이블을 사용해 결과를 병합한다.
        - 인덱스를 사용하지 못하는 정렬 작업은 임시 버퍼 공간을 사용하는데, 정렬해야 할 레코드가 많아지면 결국 디스크를 사용한다. (쿼리가 정렬을 수행할 때는 “Using filesort”라고 표시된다.)
    - 임시 테이블이나 버퍼가 메모리에 저장됐는지, 디스크에 저장됐는지는 MySQL 서버의 상태 변수값으로 확인할 수 있다.

        ```sql
        -- // Using temporary가 표시되지 않음
        EXPLAIN
        SELECT COUNT(DISTINCT last_name)
        FROM employees;
        +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------+
        | id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra |
        +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------+
        |  1 | SIMPLE      | employees | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 300695 |   100.00 | NULL  |
        +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------+
        
        -- // 현재 세션의 상태 값을 초기화
        FLUSH STATUS;
        
        -- // 임시 테이블을 사용하지 않음
        SHOW STATUS LIKE 'Created_tmp%';
        +-------------------------+-------+
        | Variable_name           | Value |
        +-------------------------+-------+
        | Created_tmp_disk_tables | 0     |
        | Created_tmp_files       | 0     |
        | Created_tmp_tables      | 0     |
        +-------------------------+-------+
        
        SELECT COUNT(DISTINCT last_name) FROM employees;
        +---------------------------+
        | COUNT(DISTINCT last_name) |
        +---------------------------+
        |                      1637 |
        +---------------------------+
        
        -- // 임시 테이블을 사용
        SHOW STATUS LIKE 'Created_tmp%';
        +-------------------------+-------+
        | Variable_name           | Value |
        +-------------------------+-------+
        | Created_tmp_disk_tables | 0     |
        | Created_tmp_files       | 0     |
        | Created_tmp_tables      | 1     |
        +-------------------------+-------+
        ```

30. **Using where**
    - **MySQL 서버**는 내부적으로 크게 MySQL 엔진과 스토리지 엔진이라는 두 개의 레이어로 나눠진다.
        - **스토리지 엔진**은 디스크나 메모리상에서 필요한 레코드를 읽거나 저장하는 역할을 한다.
        - **MySQL 엔진**은 스토리지 엔진으로부터 받은 레코드를 가공 또는 연산하는 작업을 수행한다.
    - MySQL 엔진 레이어에서 별도의 가공을 해서 필터링 작업을 처리한 경우에 표시된다.

        ```sql
        EXPLAIN
        SELECT *
        FROM employees
        WHERE emp_no BETWEEN 10001 AND 10100
          AND gender = 'F';
        +----+-------------+-----------+------------+-------+-----------------------------+---------+---------+------+------+----------+-------------+
        | id | select_type | table     | partitions | type  | possible_keys               | key     | key_len | ref  | rows | filtered | Extra       |
        +----+-------------+-----------+------------+-------+-----------------------------+---------+---------+------+------+----------+-------------+
        |  1 | SIMPLE      | employees | NULL       | range | PRIMARY,ix_gender_birthdate | PRIMARY | 4       | NULL |  100 |    50.00 | Using where |
        +----+-------------+-----------+------------+-------+-----------------------------+---------+---------+------+------+----------+-------------+
        ```

    - 실행 계획에서 Extra 칼럼에 가장 흔히 표시되는 내용이 “Using where”인데, 왜 표시 됐는지 이해할 수 없는 쿼리에서도 표시되기도 한다.
    - 그래서 “Using where”가 성능상의 문제를 일으킬지 아닐지를 적절히 파악해야 하는데, filtered 칼럼을 함께 보면 된다.
    - filtered 칼럼의 값이 50%인 것을 보면 옵티마이저는 100건 중에서 50건은 버려지고 최종 남은 50건이 반환될 것으로 예측한 것이다.

31. **Zero limit**
    - MySQL 서버에서 쿼리의 결과 값이 아닌 메타데이터를 조회하면 표시된다.
    - 쿼리의 메타데이터를 조회하려면, 쿼리의 마지막에 `LIMIT 0`을 사용하면 된다.
    - 메타데이터로 쿼리의 결과가 몇 개의 칼럼을 가지는지 각 칼럼의 타입은 무엇인지 등의 정보를 볼 수 있다.