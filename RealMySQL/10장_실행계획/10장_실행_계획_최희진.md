# 10. 실행 계획

## 1. 통계 정보

- MySQL 서버의 실행 계획에 가장 큰 영향을 미치는 것은 통계 정보이다.
- MySQL 5.7 버전까지는 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행 계획을 수립했다.

  → 하지만 실제 테이블 컬럼의 값들이 어떻게 분포되어 있는지 정보가 없어 실행 계획의 정확도가 떨어졌다.

- MySQL 8.0 버전부터는 **인덱스되지 않은 컬럼들에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입되었다.**

### 1.1 테이블 및 인덱스 통계 정보

- 비용 기반 최적화에서 가장 중요한 것은 통계 정보다.
- 통계 정보가 정확하지 않다면 전혀 엉뚱한 방향으로 쿼리를 실행할 수 있기 때문이다.

**MySQL 서버의 통계 정보 (MySQL 5.6~)**

- MySQL 5.5 버전까지는 각 테이블의 통계 정보가 메모리에만 관리되고, `SHOW INDEX` 명령으로만 테이블의 인덱스 컬럼의 분포도를 볼 수 있었다.
- MySQL 5.6 버전부터 각 테이블의 통계 정보를 mysql 데이터베이스의 `innodb_index_stats` 테이블과 `innodb_table_stats` 테이블로 관리할 수 있게 되었다.

    ```sql
    SHOW TABLES LIKE '%_stats';
    
    +---------------------------+
    | Tables_in_mysql (%_stats) |
    +---------------------------+
    | innodb_index_stats        |
    | innodb_table_stats        |
    +---------------------------+
    ```

- 테이블을 생성할 때 `STATS_PERSISTENT` 옵션을 사용하면 통계 정보를 영구적으로 보관할지 설정할 수 있다.

    ```sql
    CREATE TABLE tab_persistent (fd1 INT PRIMARY KEY, fd2 INT)
    ENGINE=InnoDB
    STATS_PERSISTENT=1;
    
    CREATE TABLE tab_trasient (fd1 INT PRIMARY KEY, fd2 INT)
    ENGINE=InnoDB
    STATS_PERSISTENT=0;
    ```

    - `STATS_PERSISTENT=0` : 테이블의 통계 정보를 MySQL 5.5 이전 버전의 방식으로 관리하며, `innodb_index_stats`와 `innodb_table_stats` 테이블에 저장하지 않음
    - `STATS_PERSISTENT=1` : 테이블의 통계 정보를 `innodb_index_stats`와 `innodb_table_stats` 테이블에 저장함
    - `STATS_PERSISTENT=DEFAULT` : 테이블을 생성할 때 별도의 `STATS_PERSISTENT` 옵션을 설정하지 않은 것과 동일하며, 테이블 통계를 영구적으로 관리할지는 `innodb_stats_persistent` 시스템 변수의 값으로 결정한다.
    - `innodb_stats_persistent` 시스템 변수의 기본 값은 `1`이다.
    
      ```sql
      SELECT * FROM mysql.innodb_table_stats
      WHERE table_name IN ('tab_persistent', 'tab_trasient') \G
    
      *************************** 1. row ***************************
                 database_name: testdb
                    table_name: tab_persistent
                   last_update: 2022-10-14 21:06:39
                        n_rows: 0
          clustered_index_size: 1
      sum_of_other_index_sizes: 0
      1 row in set (0.03 sec)
      ```

- 통계 정보의 각 컬럼은 다음과 같은 값을 저장하고 있다.
    - innodb_index_stats
        - `stat_name='d_diff_pfx%'` : 인덱스가 가진 유니크한 값의 개수
        - `stat_name='n_leaf_pages'` : 인덱스의 리프 노트 페이지 개수
        - `stat_name='size'` : 인덱스 트리의 전체 페이지 개수
    - innodb_table_status
        - `n_rows` : 테이블의 전체 레코드 건수
        - `clustered_index_size` : 프라이머리 키의 크기 (InnoDB 페이지 개수)
        - `sum_of_other_index_sizes` : 프라이머리 키를 제외한 인덱스의 크기 (InnoDB 페이지 개수)

    ```sql
    ALTER TABLE testdb.employees STATS_PERSISTENT=1;
    
    SELECT * 
    FROM mysql.innodb_index_stats
    WHERE database_name = 'testdb' AND table_name = 'employees';
  
    +---------------+------------+---------------------+---------------------+--------------+------------+-------------+-----------------------------------+
    | database_name | table_name | index_name          | last_update         | stat_name    | stat_value | sample_size | stat_description                  |
    +---------------+------------+---------------------+---------------------+--------------+------------+-------------+-----------------------------------+
    | testdb        | employees  | PRIMARY             | 2022-10-14 21:17:31 | n_diff_pfx01 |     299335 |          20 | emp_no                            |
    | testdb        | employees  | PRIMARY             | 2022-10-14 21:17:31 | n_leaf_pages |        886 |        NULL | Number of leaf pages in the index |
    | testdb        | employees  | PRIMARY             | 2022-10-14 21:17:31 | size         |        929 |        NULL | Number of pages in the index      |
    | testdb        | employees  | ix_firstname        | 2022-10-14 21:17:31 | n_diff_pfx01 |       1304 |          20 | first_name                        |
    | testdb        | employees  | ix_firstname        | 2022-10-14 21:17:31 | n_diff_pfx02 |     329443 |          20 | first_name,emp_no                 |
    | testdb        | employees  | ix_firstname        | 2022-10-14 21:17:31 | n_leaf_pages |        496 |        NULL | Number of leaf pages in the index |
    | testdb        | employees  | ix_firstname        | 2022-10-14 21:17:31 | size         |        609 |        NULL | Number of pages in the index      |
    | testdb        | employees  | ix_gender_birthdate | 2022-10-14 21:17:31 | n_diff_pfx01 |          1 |           3 | gender                            |
    | testdb        | employees  | ix_gender_birthdate | 2022-10-14 21:17:31 | n_diff_pfx02 |       9061 |          20 | gender,birth_date                 |
    | testdb        | employees  | ix_gender_birthdate | 2022-10-14 21:17:31 | n_diff_pfx03 |     309467 |          20 | gender,birth_date,emp_no          |
    | testdb        | employees  | ix_gender_birthdate | 2022-10-14 21:17:31 | n_leaf_pages |        361 |        NULL | Number of leaf pages in the index |
    | testdb        | employees  | ix_gender_birthdate | 2022-10-14 21:17:31 | size         |        417 |        NULL | Number of pages in the index      |
    | testdb        | employees  | ix_hiredate         | 2022-10-14 21:17:31 | n_diff_pfx01 |       4468 |          20 | hire_date                         |
    | testdb        | employees  | ix_hiredate         | 2022-10-14 21:17:31 | n_diff_pfx02 |     296778 |          20 | hire_date,emp_no                  |
    | testdb        | employees  | ix_hiredate         | 2022-10-14 21:17:31 | n_leaf_pages |        294 |        NULL | Number of leaf pages in the index |
    | testdb        | employees  | ix_hiredate         | 2022-10-14 21:17:31 | size         |        353 |        NULL | Number of pages in the index      |
    +---------------+------------+---------------------+---------------------+--------------+------------+-------------+-----------------------------------+
    
    SELECT *
    FROM mysql.innodb_table_stats
    WHERE database_name = 'testdb' AND table_name = 'employees';
  
    +---------------+------------+---------------------+--------+----------------------+--------------------------+
    | database_name | table_name | last_update         | n_rows | clustered_index_size | sum_of_other_index_sizes |
    +---------------+------------+---------------------+--------+----------------------+--------------------------+
    | testdb        | employees  | 2022-10-14 21:17:31 | 299335 |                  929 |                     1379 |
    +---------------+------------+---------------------+--------+----------------------+--------------------------+
    ```
    - innodb_table_stats.sum_of_other_index_size 컬럼의 값은 테이블의 `STATS_AUTO_RECALC` 옵션에 따라 `0`으로 보일 수도 있는데, `ANALYZE TABLE` 명령을 실행하면 통계값이 저장된다.

**통계 정보가 자동으로 갱신되는 이벤트**

- 테이블이 새로 오픈되는 경우
- 테이블의 레코드가 대량으로 변경되는 경우 (테이블의 전체 레코드 중에서 1/16 정도의 UPDATE 또는 INSER나 DELETE 가 실행되는 경우)
- ANALYZE TABLE 명령이 실행되는 경우
- SHOW TABLE STATUS 명령이나 SHOW INDEX FROM 명령이 실행되는 경우
- InnoDB 모니터가 활성화되는 경우
- innodb_stats_on_metadata 시스템 설정이 ON인 상태에서 SHOW TABLE STATUS 명령이 실행되는 경우
→ 테이블의 통계 정보가 자주 갱신되면 응용 프로그램의 쿼리를 레인지 스캔으로 실행하다가 풀 스캔으로 실행하는 상황이 발생할 수도 있다.
- `innodb_stats_auto_recalc` 시스템 변수의 값을 `OFF`로 설정하면 통계 정보가 자동으로 갱신되는 것을 막을 수 있다.

**통계 정보 수집을 위한 샘플링**

- MySQL 5.6 버전에서 테이블의 통계 정보를 수집할 때 몇 개의 InnoDB 테이블 블록을 샘플링할지 결정하는 옵션에는 두 가지가 있다.
    - `innodb_stats_transient_sample_pages` (기본 값 8)  
      자동으로 통계 정보 수집이 실행될 때 몇 개의 페이지를 샘플링해서 분석할지 설정
    - `innodb_stats_persistent_sample_pages` (기본 값 20)  
      ANALYZE TABLE 명령이 실행될 때 몇 개의 페이지를 샘플링해서 분석할지 설정

- 통계 정보의 정확성에 의해 쿼리의 성능이 결정되기 때문에 통계 정보의 정확성을 높이는데 시간을 투자할 가치가 충분하다.
    - 영구적인 통계 정보를 사용한다면 MySQL 서버의 점검이나 사용량이 많지 않은 시간을 이용해서 `innodb_stats_persistent_sample_pages` 값을 조정하여 더 정확한 통계 정보를 수집할 수 있다.
    - 하지만 이 값을 너무 높이면 통계 정보 수집 시간이 길어지므로 주의해야 한다.

### 1.2 히스토그램

- MySQL 8.0 버전부터 컬럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보를 활용할 수 있게 되었다.

**히스토그램 정보 수집**

- 히스토그램 정보는 컬럼 단위로 관리된다.
- 히스토그램은 자동으로 수집되지 않으므로 수동으로 명령어를 실행하여 수집해야 한다.

    ```sql
    ALTER TABLE {talbe_name} UPDATE HISTOGRAM;
    ```

- 수집된 히스토그램 정보는 시스템 딕셔너리에 저장되고, MySQL 서버가 시작될 때 딕셔너리의 히스토그램 정보를 `information_schema.column_statistics` 테이블로 로드한다.
    - 암호화된 테이블에서는 히스토그램을 수집할 수 없다. (Cannot create histogram statistics for an encrypted table)

    ```sql
    -- // 히스토그램 정보 수집
    ANALYZE TABLE testdb.employees
    UPDATE HISTOGRAM ON gender, hire_date;
  
    +------------------+-----------+----------+------------------------------------------------------+
    | Table            | Op        | Msg_type | Msg_text                                             |
    +------------------+-----------+----------+------------------------------------------------------+
    | testdb.employees | histogram | status   | Histogram statistics created for column 'gender'.    |
    | testdb.employees | histogram | status   | Histogram statistics created for column 'hire_date'. |
    +------------------+-----------+----------+------------------------------------------------------+
    
    -- // 히스토그램 정보 조회
    SELECT *
    FROM information_schema.column_statistics
    WHERE schema_name = 'testdb' AND table_name = 'employees' \G
  
    *************************** 1. row ***************************
    SCHEMA_NAME: testdb
     TABLE_NAME: employees
    COLUMN_NAME: gender
      HISTOGRAM: {"buckets": [[1, 0.6022134473264744], [2, 1.0]], "data-type": "enum", "null-values": 0.0, "collation-id": 45, "last-updated": "2022-10-18 14:48:18.023937", "sampling-rate": 0.3464196832892688, "histogram-type": "singleton", "number-of-buckets-specified": 100}
    *************************** 2. row ***************************
    SCHEMA_NAME: testdb
     TABLE_NAME: employees
    COLUMN_NAME: hire_date
      HISTOGRAM: {"buckets": [
                                ["1985-02-01", "1985-02-28", 0.009898927691638892, 28], 
                                ["1985-03-01", "1985-03-28", 0.020069555136936677, 28], 
                                ["1985-03-29", "1985-04-25", 0.0301405593392262, 28], 
                                ["1985-04-26", "1985-05-24", 0.04006665700623098, 29], 
                                ["1985-05-25", "1985-06-20", 0.05003803796551225, 27], 
                                ...
                                ["1998-08-07", "2000-01-28", 1.0, 467]
                             ], 
    "data-type": "date", 
    "null-values": 0.0, 
    "collation-id": 8, 
    "last-updated": "2022-10-18 14:48:18.033156", 
    "sampling-rate": 0.3464196832892688, 
    "histogram-type": "equi-height", 
    "number-of-buckets-specified": 100
    }
    ```

    - `sampling-rate`
        - 히스토그램 정보를 수집하기 위해 스캔한 페이지의 비율을 저장한다.
        - 샘플링 비율이 0.35라면 전체 데이터 페이지의 35%를 스캔해서 정보를 수집했다는 것을 의미한다.
        - MySQL 8.0.19 미만의 버전까지는 `histogram_generation_max_mem_size`  시스템 변수로 히스토그램 생성 시 샘플링 비율을 설정할 수 있다.
        - MySQL 8.0.19 버전부터는 InnoDB 스토리지 엔진이 자체적으로 샘플링 알고리즘을 구현하여, 히스토그램 수집 시 풀 테이블 스캔이 발생하지 않는다.
    - `histogram-type`
        - 히스토그램의 종류를 저장한다.
    - `number-of-buchkets-specified`
        - 히스토그램을 생성할 때 설정했던 버킷의 개수를 저장한다.
        - 별도로 설정하지 않으면 기본 100개의 버킷이 사용되며, 최대 1024개를 설정할 수 있다.

**히스토그램의 종류**

- 히스토그램은 버킷(Bucket) 단위로 구분되어 레코드 건수나 컬럼값의 범위를 관리한다.
1. **Singleton (싱글톤 히스토그램)**  
   컬럼값 개별로 레코드 건수를 관리하는 히스토그램  
   → 싱글톤 히스토그램은 주로 코드 값과 같이 유니크한 값의 개수가 상대적으로 적은(히스토그램의 버킷 수보다 적은) 경우 사용된다.

2. **Equi-Height (높이 균형 히스토그램)**  
   컬럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램  
   → 높이 균형 히스토그램은 컬럼의 범위에 대한 레코드 건수 비율이 누적되므로, 그래프 상으로 그래프 기울기를 의미한다.

**히스토그램의 삭제**

- 히스토그램의 삭제 작업은 테이블의 데이터를 참조하는 것이 아니라 딕셔너리의 내용만 삭제하기 때문에 다른 쿼리 처리의 성능에 영향을 주지 않고 즉시 완료된다.

    ```sql
    ANALYZE TABLE testdb.employees
    DROP HISTOGRAM ON gender, hire_date;
  
    +------------------+-----------+----------+-------------------------------------------------------+
    | Table            | Op        | Msg_type | Msg_text                                              |
    +------------------+-----------+----------+-------------------------------------------------------+
    | testdb.employees | histogram | Error    | No histogram statistics found for column 'gender'.    |
    | testdb.employees | histogram | Error    | No histogram statistics found for column 'hire_date'. |
    +------------------+-----------+----------+-------------------------------------------------------+
    ```

- 히스토그램을 삭제하지 않고 MySQL 옵티마이저가 히스토그램을 사용하지 않게 하려면 optimizer_switch 시스템 변수의 값을 변경하면 된다.

    ```sql
    SET GLOBAL optimizer_switch = 'condition_fanout_filter=off';
    
    -- // 현재 커넥션에서 실행되는 쿼리만 히스토그램을 사용하지 않게 설정
    SET SESSION optimizer_switch = 'condition_fanout_filter=off';
    
    -- // 현재 쿼리만 히스토그램을 사용하지 않게 설정
    SELECT /*+ SET_VAR(optimizer_switch = 'condition_fanout_filter=off') */ *
    FROM employees;
    ```

**히스토그램의 용도**

- 실제 응용 프로그램의 데이터는 항상 균등한 분포도를 가지지 않는다.
- 히스토그램은 특정 컬럼이 가지는 모든 값에 대한 분포도 정보를 가지지 않지만, 각 범위(버킷)별로 레코드의 건수와 유니크한 값의 개수 정보를 가지기 때문에 훨씬 정확한 예측을 할 수 있다.

    ```sql
    -- // 히스토그램을 사용하지 않고 조회
    EXPLAIN
    SELECT *
    FROM employees
    WHERE first_name = 'Zita'
      AND birth_date BETWEEN '1950-01-01' AND '1960-01-01';
  
    +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    | id | select_type | table     | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra       |
    +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    |  1 | SIMPLE      | employees | NULL       | ref  | ix_firstname  | ix_firstname | 58      | const |  224 |    11.11 | Using where |
    +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    
    -- // 히스토그램을 사용
    ANALYZE TABLE employees
      UPDATE HISTOGRAM ON first_name, birth_date;
  
    +------------------+-----------+----------+-------------------------------------------------------+
    | Table            | Op        | Msg_type | Msg_text                                              |
    +------------------+-----------+----------+-------------------------------------------------------+
    | testdb.employees | histogram | status   | Histogram statistics created for column 'birth_date'. |
    | testdb.employees | histogram | status   | Histogram statistics created for column 'first_name'. |
    +------------------+-----------+----------+-------------------------------------------------------+
    
    -- // 위의 SELECT 쿼리 재조회
  
    +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    | id | select_type | table     | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra       |
    +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    |  1 | SIMPLE      | employees | NULL       | ref  | ix_firstname  | ix_firstname | 58      | const |  224 |    60.61 | Using where |
    +----+-------------+-----------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    ```

  → 단순 통계 정보만 이용한 경우와 히스토크램을 이용한 경우의 차이가 매우 큰 것을 알 수 있다.

    ```sql
    SELECT
    SUM(
        CASE WHEN birth_date BETWEEN '1950-01-01' AND '1960-01-01' 
             THEN 1 
             ELSE 0 END
       ) / COUNT(*) AS ratio
    FROM employees 
    WHERE first_name = 'Zita';
    +--------+
    | ratio  |
    +--------+
    | 0.6384 |
    +--------+
    ```

    - 히스토그램 정보가 없으면 옵티마이저는 데이터가 균등하게 분포되어 있을 것으로 예측한다. 하지만 히스토그램이 있으면 특정 범위의 데이터가 많고 적음을 식별할 수 있다.
    - 조인의 경우에도, 히스토그램 정보가 있으면 어느 테이블을 먼저 읽어야 조인 횟수를 줄일 수 있을지 옵티마이저가 더 정확히 판단할 수 있다.

**히스토그램과 인덱스**

- 히스토그램과 인덱스는 완전히 다른 객체이기 때문에 서로 비교할 대상은 아니지만, MySQL 서버에서 인덱스는 부족한 통계 정보를 수집하기 위해 사용된다는 측면에서는 어느 정도 공통점을 가진다.
- MySQL 서버에서는 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택한다.
- **이때, 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링해서 살펴보는데, 이 작업을 인덱스 다이브(Index Dive)라고 표현한다.**
- MySQL 8.0 버전에서는 인덱스된 컬럼을 검색 조건으로 사용하는 경우, 그 컬럼의 히스토그램은 사용하지 않고 실제 인덱스 다이브를 통해 직접 수집한 정보를 활용한다.
- MySQL 8.0 버전에서 히스토그램은 주로 인덱스되지 않은 컬럼에 대한 데이터 분포를 참조하는 용도로 사용된다.
- 하지만 인덱스 다이브 작업은 어느 정도의 비용이 필요하며, 때로는 (IN 절에 많은 값을 검색하는 경우) 실행 계획 수립만으로도 상당한 인덱스 다이브를 실행하고 비용도 그만큼 커진다.

### 1.3 코스트 모델(Cost Model)

- MySQL 서버가 쿼리를 처리하기 위한 작업
    - 디스크로부터 데이터 페이지 읽기
    - 메모리(InnoDB 버퍼 풀)로부터 데이터 페이지 읽기
    - 인덱스 키 비교
    - 레코드 평가
    - 메모리 임시 테이블 작업
    - 디스크 임시 테이블 작업
- 전체 쿼리의 비용을 계산하는데 필요한 단위 작업들의 비용을 코스트 모델이라고 한다.
- 코스트 모델의 설정 테이블
    - `server_cost` : 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
    - `engine_cost` : 레코드를 가진 데이터 페이지를 가져오는데 필요한 비용 관리
- MySQL 8.0 버전의 코스트 모델에서 지원하는 단위 작업

    | type | cost_name | deafult_value | 설명 |
    | :---: | :--- | :---: | :--- |
    | engine_cost | io_block_read_cost | 1.00 | 디스크 데이터 페이지 읽기 |
    |  | memory_block_read_cost | 0.25 | 메모리 데이터 페이지 읽기 |
    | server_cost | disk_temptable_create_cost | 20.00 | 디스크 임시 테이블 생성 |
    |  | disk_temptable_row_cost | 0.50 | 디스크 임시 테이블의 레코드 읽기 |
    |  | key_compare_cost | 0.05 | 인덱스 비교 |
    |  | memory_temptable_create_cost | 1.00 | 메모리 임시 테이블 생성 |
    |  | memory_temptable_row_cost | 0.10 | 메모리 임시 테이블의 레코드 읽기 |
    |  | row_evaluate_cost | 0.10 | 레코드 비교 |

    - 단위 작업의 비용이 변경될 때 예상할 수 있는 결과
        - `key_compare_cost` 비용을 높이면 MySQL 서버 옵티마이저가 가능하면 정렬을 수행하지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.
        - `row_evaluate_cost` 비용을 높이면 풀 스캔을 실행하는 쿼리들의 비용이 높아지고, 인덱스 레인지 스캔을 사용하는 실행 계획을 선택할 가능성이 높아진다.
        - `disk_temptable_create_cost`와 `disk_temptable_row_cost` 비용을 높이면, 디스크에 임시 테이블을 만들지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.
        - `memory_temptable_create_cost`와 `memory_temptable_row_cost` 비용을 높이면, 메모리 임시 테이블을 만들지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.
        - `io_block_read_cost` 비용이 높아지면, InnoDB 버퍼 풀에 데이터 페이지가 많이 적재되어 있는 인덱스를 사용하는 실행 계획을 선택할 가능성이 높아진다.
        - `memory_block_read_cost` 비용이 높아지면, InnoDB 버퍼 풀에 적재된 데이터 페이지가 상대적으로 적다고 하더라도 그 인덱스를 사용할 가능성이 높아진다.
- 각 실행 계획의 계산된 비용(Cost) 확인

    ```sql
    -- // TREE 포맷 조회
    EXPLAIN FORMAT = TREE
    SELECT *
    FROM employees WHERE first_name = 'Matt' \G
    
    *************************** 1. row ***************************
    EXPLAIN: -> Index lookup on employees using ix_firstname (first_name='Matt')  (cost=147.01 rows=233)
    
    -- // JSON 포맷 조회
    EXPLAIN FORMAT = JSON
    SELECT *
    FROM employees WHERE first_name = 'Matt' \G
    
    *************************** 1. row ***************************
    EXPLAIN: {
      "query_block": {
        "select_id": 1,
        "cost_info": {
          "query_cost": "147.01"
        },
        "table": {
          "table_name": "employees",
          "access_type": "ref",
          "possible_keys": [
            "ix_firstname"
          ],
          "key": "ix_firstname",
          "used_key_parts": [
            "first_name"
          ],
          "key_length": "58",
          "ref": [
            "const"
          ],
          "rows_examined_per_scan": 233,
          "rows_produced_per_join": 233,
          "filtered": "100.00",
          "cost_info": {
            "read_cost": "123.71",
            "eval_cost": "23.30",
            "prefix_cost": "147.01",
            "data_read_per_join": "30K"
          },
          "used_columns": [
            "emp_no",
            "birth_date",
            "first_name",
            "last_name",
            "gender",
            "hire_date"
          ]
        }
      }
    }
    ```

  **→ 코스트 모델에서 중요한 것은 각 단위 작업에 설정되는 값에 따라 실행 계획의 비용을 파악하는 것이다.**

## 3. 실행 계획 분석

- 실행 계획이 어떤 접근 방법을 사용해서 최적화를 수행하는지, 어떤 인덱스를 사용하는지 등을 이해하는 것이 중요하다.
- 아무런 옵션 없이 `EXPLAIN` 명령을 실행하면 표 형태로 표시된다.
    - 표의 각 레코드는 사용된 테이블의 개수만큼 출력된다.
    - 실행 순서는 위에서 아래로 순서대로 표시된다. (UNION이나 상관 서브쿼리와 같은 경우 순서대로 표시되지 않을 수도 있다.)
    - 위쪽에 출력된 결과일수록(id 컬럼의 값이 작을수록) 쿼리의 바깥(Outer) 부분이거나 먼저 접근한 테이블이다.
    - 아래쪽에 출력된 결과일수록(id 컬럼의 값이 클수록) 쿼리의 안쪽(Inner) 부분이거나 나중에 접근한 테이블이다.

### 3.1 id 칼럼

- 하나의 `SELECT` 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만 **같은 id 값이 부여된다.**

    ```sql
    EXPLAIN 
    SELECT e.emp_no, e.first_name, s.from_date, s.salary
    FROM employees e, salaries s
    WHERE e.emp_no = s.emp_no
    LIMIT 10;
    
    +----+-------------+-------+------------+-------+---------------+--------------+---------+-----------------+--------+----------+-------------+
    | id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref             | rows   | filtered | Extra       |
    +----+-------------+-------+------------+-------+---------------+--------------+---------+-----------------+--------+----------+-------------+
    |  1 | SIMPLE      | e     | NULL       | index | PRIMARY       | ix_firstname | 58      | NULL            | 300596 |   100.00 | Using index |
    |  1 | SIMPLE      | s     | NULL       | ref   | PRIMARY       | PRIMARY      | 4       | testdb.e.emp_no |      9 |   100.00 | NULL        |
    +----+-------------+-------+------------+-------+---------------+--------------+---------+-----------------+--------+----------+-------------+
    ```

- 하나의 `SELECT` 문장은 1개 이상의 하위 `SELECT` 문장을 포함할 수 있는데, 단위 `SELECT` 쿼리로 구성된 실행 계획에서는 **서로 다른 id이값 부여된다.**

    ```sql
    EXPLAIN
    SELECT(
        (SELECT COUNT(*) FROM employees) + (SELECT COUNT(*) FROM departments)
    ) AS total_count;
    
    +----+-------------+-------------+------------+-------+---------------+-------------+---------+------+--------+----------+----------------+
    | id | select_type | table       | partitions | type  | possible_keys | key         | key_len | ref  | rows   | filtered | Extra          |
    +----+-------------+-------------+------------+-------+---------------+-------------+---------+------+--------+----------+----------------+
    |  1 | PRIMARY     | NULL        | NULL       | NULL  | NULL          | NULL        | NULL    | NULL |   NULL |     NULL | No tables used |
    |  3 | SUBQUERY    | departments | NULL       | index | NULL          | ux_deptname | 162     | NULL |      9 |   100.00 | Using index    |
    |  2 | SUBQUERY    | employees   | NULL       | index | NULL          | ix_hiredate | 3       | NULL | 300596 |   100.00 | Using index    |
    +----+-------------+-------------+------------+-------+---------------+-------------+---------+------+--------+----------+----------------+
    ```

- 한 가지 주의할 점은 실행 계획의 id 컬럼이 테이블의 접근 순서를 의미하지는 않는다는 것이다.

    ```sql
    EXPLAIN FORMAT=TREE
    SELECT *
    FROM dept_emp de
    WHERE de.emp_no = (
        SELECT e.emp_no
        FROM employees e
        WHERE e.first_name = 'Georgi'
          AND e.last_name = 'Facello'
        LIMIT 1
    );
    
    +---------+
    | EXPLAIN |
    +---------+
    -> Filter: (de.emp_no = (select #2))  (cost=1.10 rows=1)
        -> Index lookup on de using ix_empno_fromdate (emp_no=(select #2))  (cost=1.10 rows=1)
        -> Select #2 (subquery in condition; run only once)
            -> Limit: 1 row(s)
                -> Filter: (e.last_name = 'Facello')  (cost=253.71 rows=25)
                    -> Index lookup on e using ix_firstname (first_name='Georgi')  (cost=253.71 rows=253)
    ```

  → **쿼리의 실행 순서를 확인하기 위해서는 TABLE 포맷보다 TREE 포맷으로 확인해보면 순서를 더 정확히 알 수 있다.**


### 3.2 select_type 칼럼

- 각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼이다.
1. `SIMPLE`
    - UNION이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우 `SIMPLE`이 표시된다.
    - 쿼리 문장이 아무리 복잡하더라도 select_type이 `SIMPLE`인 단위 쿼리는 하나만 존재한다.
    - 일반적으로 제일 바깥 SELECT에 해당한다.
2. `PRIMARY`
    - UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽(Outer)에 있는 단위 쿼리에 `PRIMARY`가 표시된다.
    - select_type이 `PRIMARY`인 단위 쿼리는 하나만 존재한다.
3. `UNION`
    - UNION으로 결합하는 단위 SELECT 쿼리 가운데 두번째 이후 단위 SELECT 쿼리에 `UNION`이 표시된다.
    - UNION의 첫번째 단위 SELECT는 `DERIVED`(임시테이블)로 표시된다.

    ```sql
    EXPLAIN
    SELECT * FROM (
        (SELECT emp_no FROM employees e1 LIMIT 10) UNION ALL
        (SELECT emp_no FROM employees e2 LIMIT 10) UNION ALL
        (SELECT emp_no FROM employees e3 LIMIT 10)
    ) AS union_result;
    
    +----+-------------+------------+------------+-------+---------------+-------------+---------+------+--------+----------+-------------+
    | id | select_type | table      | partitions | type  | possible_keys | key         | key_len | ref  | rows   | filtered | Extra       |
    +----+-------------+------------+------------+-------+---------------+-------------+---------+------+--------+----------+-------------+
    |  1 | PRIMARY     | <derived2> | NULL       | ALL   | NULL          | NULL        | NULL    | NULL |     30 |   100.00 | NULL        |
    |  2 | DERIVED     | e1         | NULL       | index | NULL          | ix_hiredate | 3       | NULL | 300596 |   100.00 | Using index |
    |  3 | UNION       | e2         | NULL       | index | NULL          | ix_hiredate | 3       | NULL | 300596 |   100.00 | Using index |
    |  4 | UNION       | e3         | NULL       | index | NULL          | ix_hiredate | 3       | NULL | 300596 |   100.00 | Using index |
    +----+-------------+------------+------------+-------+---------------+-------------+---------+------+--------+----------+-------------+
    ```

4. `DEPENDENT UNION`
    - DEPENDENT는 UNION이나 UNION ALL로 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미한다.
    - 내부 쿼리가 외부의 값을 참조해서 처리되는 경우 `DEPENDENT UNION`이 표시된다.

    ```sql
    EXPLAIN
    SELECT *
    FROM employees e1 
    WHERE e1.emp_no IN (
        SELECT e2.emp_no FROM employees e2 WHERE e2.first_name = 'Matt'
        UNION ALL
        SELECT e3.emp_no FROM employees e3 WHERE e3.last_name = 'Matt'
    );
    
    +----+--------------------+-------+------------+--------+----------------------+---------+---------+------+--------+----------+-------------+
    | id | select_type        | table | partitions | type   | possible_keys        | key     | key_len | ref  | rows   | filtered | Extra       |
    +----+--------------------+-------+------------+--------+----------------------+---------+---------+------+--------+----------+-------------+
    |  1 | PRIMARY            | e1    | NULL       | ALL    | NULL                 | NULL    | NULL    | NULL | 300596 |   100.00 | Using where |
    |  2 | DEPENDENT SUBQUERY | e2    | NULL       | eq_ref | PRIMARY,ix_firstname | PRIMARY | 4       | func |      1 |     5.00 | Using where |
    |  3 | DEPENDENT UNION    | e3    | NULL       | eq_ref | PRIMARY              | PRIMARY | 4       | func |      1 |    10.00 | Using where |
    +----+--------------------+-------+------------+--------+----------------------+---------+---------+------+--------+----------+-------------+
    ```

5. `UNION RESULT`
    - UNION RESULT는 UNION 결과를 담아두는 테이블을 의미한다.
    - UNION RESULT는 실제 쿼리에서 단위 쿼리가 아니기 때문에 별도의 id 값은 부여되지 않는다.
    - MySQL 8.0 이전 버전에서는 `UNION ALL`이나 `UNION`(또는 `UNION DISTINCT`) 쿼리의 UNION 결과를 임시테이블로 생성했다.
    - MySQL 8.0 버전부터 `UNION ALL`의 경우에는 임시테이블을 사용하지 않도록 개선되었다.

        ```sql
        EXPLAIN
        SELECT emp_no FROM salaries WHERE salary > 100000
        UNION DISTINCT
        SELECT emp_no FROM dept_emp WHERE from_date > '2001-01-01';
        
        +----+----------------+------------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
        | id | select_type    | table      | partitions | type  | possible_keys                 | key         | key_len | ref  | rows   | filtered | Extra                    |
        +----+----------------+------------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
        |  1 | PRIMARY        | salaries   | NULL       | range | ix_salary                     | ix_salary   | 4       | NULL | 188518 |   100.00 | Using where; Using index |
        |  2 | UNION          | dept_emp   | NULL       | range | ix_fromdate,ix_empno_fromdate | ix_fromdate | 3       | NULL |   5325 |   100.00 | Using where; Using index |
        | NULL | UNION RESULT | <union1,2> | NULL       | ALL   | NULL                          | NULL        | NULL    | NULL |   NULL |     NULL | Using temporary          |
        +----+----------------+------------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
        
        EXPLAIN
        SELECT emp_no FROM salaries WHERE salary > 100000
        UNION ALL
        SELECT emp_no FROM dept_emp WHERE from_date > '2001-01-01';
        
        +----+-------------+----------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
        | id | select_type | table    | partitions | type  | possible_keys                 | key         | key_len | ref  | rows   | filtered | Extra                    |
        +----+-------------+----------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
        |  1 | PRIMARY     | salaries | NULL       | range | ix_salary                     | ix_salary   | 4       | NULL | 188518 |   100.00 | Using where; Using index |
        |  2 | UNION       | dept_emp | NULL       | range | ix_fromdate,ix_empno_fromdate | ix_fromdate | 3       | NULL |   5325 |   100.00 | Using where; Using index |
        +----+-------------+----------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
        ```

        - table 컬럼의 `<union1,2>`은 id가 1인 단위 쿼리의 조회 결과와 id가 2인 단위 쿼리의 조회 결과를 UNION 했다는 것을 의미한다.
6. `SUBQUERY`
    - select_type의 SUBQUERY는 FROM절 이외에서 사용되는 서브쿼리만을 의미한다.
    - **FROM 절에 사용된 서브쿼리는 select_type이 `DERIVED`로 표시되고, 그 밖의 위치에서 사용된 서브쿼리는 전부 `SUBQUERY`로 표시된다.**

        ```sql
        EXPLAIN
        SELECT e.first_name,
               (SELECT COUNT(*) 
                FROM dept_emp de, dept_manager dm 
                WHERE dm.dept_no = de.dept_no
               ) AS cnt
        FROM employees e
        WHERE e.emp_no = 10001;
        
        +----+-------------+-------+------------+-------+---------------+---------+---------+-------------------+-------+----------+-------------+
        | id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref               | rows  | filtered | Extra       |
        +----+-------------+-------+------------+-------+---------------+---------+---------+-------------------+-------+----------+-------------+
        |  1 | PRIMARY     | e     | NULL       | const | PRIMARY       | PRIMARY | 4       | const             |     1 |   100.00 | NULL        |
        |  2 | SUBQUERY    | dm    | NULL       | index | PRIMARY       | PRIMARY | 20      | NULL              |    24 |   100.00 | Using index |
        |  2 | SUBQUERY    | de    | NULL       | ref   | PRIMARY       | PRIMARY | 16      | testdb.dm.dept_no | 41392 |   100.00 | Using index |
        +----+-------------+-------+------------+-------+---------------+---------+---------+-------------------+-------+----------+-------------+
        ```

    - 서브쿼리는 사용하는 위치에 따라 각각 다른 이름을 갖는다.
        - 중첩된 쿼리(Nested Query) : SELECT 칼럼에 사용된 서브쿼리
        - 서브쿼리(Subquery) : WHERE 절에 사용된 서브쿼리
        - 파생 테이블(Derived Table) : FROM 절에 사용된 서브쿼리 (=인라인 뷰, =서브 셀렉트)
    - 서브쿼리가 반환하는 값의 특성에 따라 분류하기도 한다.
        - 스칼라 서브쿼리(Scalar Subquery) : 하나의 값만(칼럼이 단 하나인 레코드 1건) 반환하는 쿼리
        - 로우 서브쿼리(Row Subquery) : 칼럼의 개수와 관계없이 하나의 레코드만 반환하는 쿼리
7. `DEPENDENT SUBQUERY`
    - 서브쿼리가 바깥쪽(Outer) SELECT 쿼리에 정의된 칼럼을 사용하는 경우 `DEPENDENT SUBQUERY`가 표시된다.
        - 안쪽의 서브쿼리 결과가 바깥쪽 컬럼에 의존적이기 때문에 `DEPENDENT` 키워드가 붙는다.
        - 외부 쿼리가 먼저 수행된 후 내부 쿼리(서브쿼리)가 실행되므로, 일반 서브쿼리보다 처리 속도가 느릴 때가 많다.

    ```sql
    EXPLAIN
    SELECT e.first_name,
           (SELECT COUNT(*) 
            FROM dept_emp de, dept_manager dm 
            WHERE dm.dept_no = de.dept_no 
              AND de.emp_no = e.emp_no
           ) AS cnt
    FROM employees e
    WHERE e.first_name = 'Matt';
    
    +----+--------------------+-------+------------+------+---------------------------+-------------------+---------+-------------------+------+----------+-------------+
    | id | select_type        | table | partitions | type | possible_keys             | key               | key_len | ref               | rows | filtered | Extra       |
    +----+--------------------+-------+------------+------+---------------------------+-------------------+---------+-------------------+------+----------+-------------+
    |  1 | PRIMARY            | e     | NULL       | ref  | ix_firstname              | ix_firstname      | 58      | const             |  233 |   100.00 | Using index |
    |  2 | DEPENDENT SUBQUERY | de    | NULL       | ref  | PRIMARY,ix_empno_fromdate | ix_empno_fromdate | 4       | testdb.e.emp_no   |    1 |   100.00 | Using index |
    |  2 | DEPENDENT SUBQUERY | dm    | NULL       | ref  | PRIMARY                   | PRIMARY           | 16      | testdb.de.dept_no |    2 |   100.00 | Using index |
    +----+--------------------+-------+------------+------+---------------------------+-------------------+---------+-------------------+------+----------+-------------+
    ```

8. `DERIVED`
    - **MySQL은 FROM 절의 서브쿼리를 임시 테이블로 만들어서 처리한다.**
    - DERIVED는 단위 SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다.
        - **select_type이 DERIVED인 경우에 생성되는 임시 테이블을 파생 테이블이라고도 한다.**
        - MySQL 5.5 버전까지는 파생 테이블에는 인덱스가 전혀 없으므로 다른 테이블과 조인할 때 성능상 불리할 때가 많았다.
        - MySQL 5.6 버전부터는 옵티마이저 옵션에 따라 임시 테이블에도 인덱스를 추가해서 만들 수 있게 최적화되었다.

        ```sql
        EXPLAIN
        SELECT *
        FROM (SELECT de.emp_no FROM dept_emp de GROUP BY de.emp_no) tb,
          employees e
        WHERE e.emp_no = tb.emp_no;
        
        +----+-------------+------------+------------+--------+---------------------------------------+-------------------+---------+-----------+--------+----------+-------------+
        | id | select_type | table      | partitions | type   | possible_keys                         | key               | key_len | ref       | rows   | filtered | Extra       |
        +----+-------------+------------+------------+--------+---------------------------------------+-------------------+---------+-----------+--------+----------+-------------+
        |  1 | PRIMARY     | <derived2> | NULL       | ALL    | NULL                                  | NULL              | NULL    | NULL      | 331143 |   100.00 | NULL        |
        |  1 | PRIMARY     | e          | NULL       | eq_ref | PRIMARY                               | PRIMARY           | 4       | tb.emp_no |      1 |   100.00 | NULL        |
        |  2 | DERIVED     | de         | NULL       | index  | PRIMARY,ix_fromdate,ix_empno_fromdate | ix_empno_fromdate | 7       | NULL      | 331143 |   100.00 | Using index |
        +----+-------------+------------+------------+--------+---------------------------------------+-------------------+---------+-----------+--------+----------+-------------+
        ```

    - MySQL 5.6 버전부터는 옵티마이저 옵션에 따라 FROM 절의 서브쿼리를 외부 쿼리와 통합하는 형태의 최적화가 수행되기도 한다.

   **→ 서브쿼리에 대한 최적화가 개선되었지만, 옵티마이저가 처리하는데 여전히 한계가 있으므로 가능하면 DERIVED 형태의 실행 계획을 조인으로 바꿔주는 것이 좋다.**

   **→ selet_type이 DERIVED인 것은 쿼리를 튜닝할 때 가장 먼저 확인해야 하는 부분이다.**
   서브쿼리는 개발자가 작성하기 편하지만, 쿼리의 성능은 떨어지므로 나중에는 반드시 서브쿼리를 조인으로 풀어서 고쳐 쓰는 것을 권장한다.

9. `DEPENDENT DERIVED`
    - MySQL 8.0 버전부터는 래터럴 조인(LATERAL JOIN) 기능이 추가되면서 FROM 절의 서브쿼리에서도 외부 칼럼을 참조할 수 있게 되었다.

        ```sql
        EXPLAIN
        SELECT *
        FROM employees e
        LEFT JOIN LATERAL
          (SELECT *
           FROM salaries s
           WHERE s.emp_no = e.emp_no
           ORDER BY s.from_date DESC
           LIMIT 2
          ) AS s2
        ON s2.emp_no = e.emp_no;
        
        +----+-------------------+------------+------------+------+---------------+-------------+---------+-----------------+--------+----------+----------------------------+
        | id | select_type       | table      | partitions | type | possible_keys | key         | key_len | ref             | rows   | filtered | Extra                      |
        +----+-------------------+------------+------------+------+---------------+-------------+---------+-----------------+--------+----------+----------------------------+
        |  1 | PRIMARY           | e          | NULL       | ALL  | NULL          | NULL        | NULL    | NULL            | 300596 |   100.00 | Rematerialize (<derived2>) |
        |  1 | PRIMARY           | <derived2> | NULL       | ref  | <auto_key0>   | <auto_key0> | 4       | testdb.e.emp_no |      2 |   100.00 | NULL                       |
        |  2 | DEPENDENT DERIVED | s          | NULL       | ref  | PRIMARY       | PRIMARY     | 4       | testdb.e.emp_no |      9 |   100.00 | Using filesort             |
        +----+-------------------+------------+------------+------+---------------+-------------+---------+-----------------+--------+----------+----------------------------+
        ```

10. `UNCACHEABLE SUBQUERY`
    - 하나의 쿼리 문장에 서브쿼리가 하나만 있더라도 실제 그 서브쿼리가 한 번만 실행되는 것은 아니다.
    - 조건이 똑같은 서브쿼리가 실행될 때는 다시 실행하지 않고 이전의 실행 결과를 그대로 사용할 수 있게 서브쿼리의 결과를 내부적인 캐시 공간에 담아둔다.
    - 캐시를 사용하는 방법 비교
        - `SUBQUERY`: 바깥쪽(Outer)의 영향을 받지 않으므로 처음 한 번만 실행해서 그 결과를 캐시하고 필요할 때 캐시된 결과를 이용한다.
        - `DEPENDENT SUBQUERY`: 의존하는 바깥쪽(Outer) 쿼리의 칼럼 값 단위로 캐시해두고 사용한다.
    - 서브쿼리에 포함된 요소에 의해 캐시 자체가 불가능한 경우 `UNCACHEABLE SUBQUERY`가 표시된다.
    - 서브쿼리에서 캐시를 사용하지 못하는 요소
        - 사용자 변수가 서브쿼리에 사용된 경우
        - NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리 내에 사용된 경우
        - UUID()나 RAND()와 같이 결과값이 호출할 때마다 달라지는 함수가 서브쿼리에 사용된 경우

        ```sql
        EXPLAIN
        SELECT *
        FROM employees e
        WHERE e.emp_no = (
            SELECT @status FROM dept_emp de WHERE de.dept_no = 'd0005'
        );
        
        +----+----------------------+-------+------------+------+---------------------------------------+---------+---------+-------+--------+----------+--------------------------+
        | id | select_type          | table | partitions | type | possible_keys                         | key     | key_len | ref   | rows   | filtered | Extra                    |
        +----+----------------------+-------+------------+------+---------------------------------------+---------+---------+-------+--------+----------+--------------------------+
        |  1 | PRIMARY              | e     | NULL       | ALL  | NULL                                  | NULL    | NULL    | NULL  | 300596 |   100.00 | Using where              |
        |  2 | UNCACHEABLE SUBQUERY | de    | NULL       | ref  | PRIMARY,ix_fromdate,ix_empno_fromdate | PRIMARY | 16      | const |      1 |   100.00 | Using where; Using index |
        +----+----------------------+-------+------------+------+---------------------------------------+---------+---------+-------+--------+----------+--------------------------+
        ```

11. `UNCACHEABLE UNION`
    - UNION과 UNCACHEABLE 키워드의 속성이 혼합된 형태를 의미한다.
12. `MATERIALIZED`
    - MySQL 5.6 버전부터 도입된 select_type으로, 주로 FROM 절이나 IN(subquery) 형태의 쿼리에 서브쿼리의 최적화를 위해 사용된다.
        - MySQL 5.6 버전까지는 employees 테이블을 읽어서 employees 테이블의 레코드마다 salaries 테이블을 읽는 서브쿼리가 실행되는 형태로 처리됐다.
        - MySQL 5.7 버전부터는 서브쿼리의 내용을 임시 테이블로 구체화(Meterialization)한 후, 임시 테이블과 employees 테이블을 조인하는 형태로 최적화되어 처리된다.

    ```sql
    EXPLAIN
    SELECT *
    FROM employees e
    WHERE e.emp_no IN (
        SELECT emp_no FROM salaries WHERE salary BETWEEN 100 AND 1000
    );
    
    +----+--------------+-------------+------------+--------+-------------------+-----------+---------+--------------------+------+----------+--------------------------+
    | id | select_type  | table       | partitions | type   | possible_keys     | key       | key_len | ref                | rows | filtered | Extra                    |
    +----+--------------+-------------+------------+--------+-------------------+-----------+---------+--------------------+------+----------+--------------------------+
    |  1 | SIMPLE       | <subquery2> | NULL       | ALL    | NULL              | NULL      | NULL    | NULL               | NULL |   100.00 | NULL                     |
    |  1 | SIMPLE       | e           | NULL       | eq_ref | PRIMARY           | PRIMARY   | 4       | <subquery2>.emp_no |    1 |   100.00 | NULL                     |
    |  2 | MATERIALIZED | salaries    | NULL       | range  | PRIMARY,ix_salary | ix_salary | 4       | NULL               |    1 |   100.00 | Using where; Using index |
    +----+--------------+-------------+------------+--------+-------------------+-----------+---------+--------------------+------+----------+--------------------------+
    ```


### 3.3 table 칼럼

- MySQL 서버의 실행 계획은 단위 SELECT 쿼리 기준이 아니라 테이블 기준으로 표시된다.
- 별도의 테이블을 사용하지 않는 SELECT 쿼리인 경우에는 table 컬럼에 NULL이 표시된다.

    ```sql
    EXPLAIN SELECT NOW();
    EXPLAIN SELECT NOW() FROM DUAL;
    
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
    |  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
    ```

    - MySQL 서버는 별도의 테이블을 사용하지 않는 SELECT 쿼리인 경우에는 table 칼럼에 NULL이 표시된다.
- table 칼럼에 `<derived N>` 또는 `<union M,N>`과 같이 “<>”로 둘러싸인 이름이 명시되는 경우 임시 테이블을 의미한다.

    ```sql
    EXPLAIN
    SELECT * 
    FROM 
        (SELECT de.emp_no FROM dept_emp de GROUP BY de.emp_no) tb,
        employees e
    WHERE e.emp_no = tb.emp_no;
    
    +----+-------------+------------+------------+--------+---------------------------------------+-------------------+---------+-----------+--------+----------+-------------+
    | id | select_type | table      | partitions | type   | possible_keys                         | key               | key_len | ref       | rows   | filtered | Extra       |
    +----+-------------+------------+------------+--------+---------------------------------------+-------------------+---------+-----------+--------+----------+-------------+
    |  1 | PRIMARY     | <derived2> | NULL       | ALL    | NULL                                  | NULL              | NULL    | NULL      | 331143 |   100.00 | NULL        |
    |  1 | PRIMARY     | e          | NULL       | eq_ref | PRIMARY                               | PRIMARY           | 4       | tb.emp_no |      1 |   100.00 | NULL        |
    |  2 | DERIVED     | de         | NULL       | index  | PRIMARY,ix_fromdate,ix_empno_fromdate | ix_empno_fromdate | 7       | NULL      | 331143 |   100.00 | Using index |
    +----+-------------+------------+------------+--------+---------------------------------------+-------------------+---------+-----------+--------+----------+-------------+
    ```

    - <derived2> : 단위 SELECT 쿼리의 id 값이 2인 실행 계획으로부터 만들어진 파생 테이블 → id 값이 2인 실행 계획이 먼저 실행되어야 함
    - select_type= DERIVED, table=de : dept_emp 테이블을 읽어서 파생 테이블을 생성
    - id 값은 실행 계획은 조인 쿼리로 실행되는데, 더 먼저 표시된 테이블이 드라이빙 테이블
- select_type이 MATERIALIZED 인 실행 계획에서 `<subquery N>`은 서브쿼리의 결과를 구체화해서 임시 테이블로 만들었다는 의미로, `<derived N>`과 같은 방법으로 해석한다.

### 3.4 partitions 칼럼

- MySQL 5.7 버전까지는 옵티마이저가 사용하는 파티션 목록을 `EXPLAIN PARTITION` 으로 확인해야 한다.
- MySQL 8.0 버전부터는 `EXPLAIN` 명령으로 파티션 관련 실행 계획을 확인할 수 있다.
- 파티션 테이블 생성

    ```sql
    CREATE TABLE employees_2 (
      emp_no INT NOT NULL,
      birth_date DATE NOT NULL,
      first_name VARCHAR(14) NOT NULL,
      last_name VARCHAR(16) NOT NULL,
      gender ENUM('M', 'F') NOT NULL,
      hire_date DATE NOT NULL,
      PRIMARY KEY(emp_no, hire_date)
    ) PARTITION BY RANGE COLUMNS(hire_date)
    (  
      PARTITION p1986_1990 VALUES LESS THAN ('1990-01-01'),
      PARTITION p1991_1995 VALUES LESS THAN ('1996-01-01'),
      PARTITION p1996_2000 VALUES LESS THAN ('2000-01-01'),
      PARTITION p2001_2005 VALUES LESS THAN ('2006-01-01')
    );
    
    INSERT INTO employees_2 SELECT * FROM employees;
    ```

- 파티션 목록 조회

    ```sql
    EXPLAIN
    SELECT *
    FROM employees_2
    WHERE hire_date BETWEEN '1999-11-15' AND '2000-01-15';
    
    +----+-------------+-------------+-----------------------+------+---------------+------+---------+------+-------+----------+-------------+
    | id | select_type | table       | partitions            | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |
    +----+-------------+-------------+-----------------------+------+---------------+------+---------+------+-------+----------+-------------+
    |  1 | SIMPLE      | employees_2 | p1996_2000,p2001_2005 | ALL  | NULL          | NULL | NULL    | NULL | 21736 |    11.11 | Using where |
    +----+-------------+-------------+-----------------------+------+---------------+------+---------+------+-------+----------+-------------+
    ```

    - `p1996_2000`, `p2001_2005` 테이블만 테이블 풀 스캔을 수행한다.
    - RDBMS에서 지원하는 파티션은 물리적으로 개별 테이블처럼 별도의 저장공간을 가지기 때문에 type 컬림에 ALL로 표시된다.
- 파티션이 있는 테이블에서 불필요한 테이블을 제외하고 필요한 테이블만 선택하는 작업을 파티션 프루닝이라고 한다.

### 3.5 type 칼럼

- type 칼럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다.
    - type 칼럼의 값을 보고 인덱스를 사용했는지, 풀 테이블 스캔을 사용했는지 등을 확인 할 수 있.

  → 실행 계획에서 type 칼럼은 반드시 체크해야 할 중요한 정보이다.

- **type 칼럼의 접근 방법 (성능이 빠른 순서)**


    | system | 실무에서 잘 사용되는 경우 거의 없음 |
    | --- | --- |
    | const | 조인의 순서와 관계 없이 프라이머리 키나 유니크 키의 모든 칼럼에 대해 동등 조건으로 검색하면 반드시 1건이 레코드만 반환 |
    | eq_ref | 조인에서 첫 번째 읽은 테이블의 칼럼값을 이용해 두 번째 테이블을 프라이머리 키나 유니크 키로 동등 비교 조건 검색하면 반드시 1건의 레코드만 반환 |
    | ref | 조인의 순서와 인덱스의 종류에 관계 없이 동등 조건으로 검색하면  1건의 레코드만 반환된다는 보장이 없음 |
    | fulltext | 전문 검색(Full-text Search) 인덱스를 사용 |
    | ref_or_null | ref에서 NULL 비교가 추가 |
    | unique_subquery | IN(subquery) 형태의 조건에서 subquery의 반환 값에는 중복이 없으므로 별도의 중복 제거 작업이 필요하지 않음 |
    | index_subquery | IN(sunquery) 형태의 조건에서 subquery의 반환 값에 중복된 값이 있을 수 있지만 인덱스를 이용해 중복된 값을 제거할 수 있음 |
    | rage | 범위 검색시 사용되는 쿼리로 애플리케이션에서 가장 많이 사용됨 |
    | index_merge | 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어 낸 후 그 결과를 병합해서 처리 |
    | index | 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의 |
    | all | 테이블을 처음부터 끝까지 전부 읽어서 (체크 조건이 존재할 때) 불필요한 레코드를 제거하고 레코드를 반환 |
- 하나의 단위 SELECT 쿼리에서 하나의 type 칼럼만 사용된다.
- ALL을 제외한 나머지는 모두 인덱스를 사용하며, index_merge를 제외한 나머지는 모두 하나의 인덱스만 사용한다.

1. `**system**`
    - **레코드가 1건만 존재하거나 1건도 없는 테이블을 참조하는 방식이다.**

        ```sql
        -- // MyISAM 엔진
        CREATE TABLE tb_dual (fd1 INT NOT NULL) ENGINE=MyISAM;
        INSERT INTO tb_dual VALUES (1);
        
        EXPLAIN SELECT fd1 FROM tb_dual;
        +----+-------------+---------+------------+--------+---------------+------+---------+------+------+----------+-------+
        | id | select_type | table   | partitions | type   | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
        +----+-------------+---------+------------+--------+---------------+------+---------+------+------+----------+-------+
        |  1 | SIMPLE      | tb_dual | NULL       | system | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |
        +----+-------------+---------+------------+--------+---------------+------+---------+------+------+----------+-------+
        
        -- // InnoDB 엔진 - type 칼럼이 ALL 또는 index로 표시될 가능성이 크다.
        CREATE TABLE tb_dual_2 (fd1 INT NOT NULL) ENGINE=InnoDB;
        INSERT INTO tb_dual_2 VALUES (1);
        
        EXPLAIN SELECT fd1 FROM tb_dual_2;
        +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------+
        | id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
        +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------+
        |  1 | SIMPLE      | tb_dual_2 | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |
        +----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------+
        ```


    → system은 테이블에 레코드가 1건 이하인 경우에만 사용할 수 있으므로 실제 애플리케이션에서 사용되는 쿼리에서는 거의 보이지 않는 실행 계획이다.

2. `**const**`
    - **WHERE 조건절에 프라이머리 키나 유니크 키 칼럼을 이용할 수 있으며, 레코드를 1건만 반환하는 쿼리의 처리 방식이다.**
    - 이 방식을 유니크 인덱스 스캔이라고도 한다.

        ```sql
        EXPLAIN
        SELECT * FROM employees WHERE emp_no = 10001;
        +----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
        | id | select_type | table     | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
        +----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
        |  1 | SIMPLE      | employees | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
        +----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
        ```

    - 다중 칼럼으로 구성된 프라이머리 키에서 일부만 조건으로 사용할 때는 type에 const가 아닌 ref로 표시된다.

        ```sql
        EXPLAIN
        SELECT * FROM dept_emp WHERE dept_no = 'd005';
        +----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
        | id | select_type | table    | partitions | type | possible_keys | key     | key_len | ref   | rows   | filtered | Extra |
        +----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
        |  1 | SIMPLE      | dept_emp | NULL       | ref  | PRIMARY       | PRIMARY | 16      | const | 165571 |   100.00 | NULL  |
        +----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
        ```

    - 프라이머리 키나 유니크 인덱스의 모든 칼럼을 동등 조건으로 WHERE 절에 명시하면 const 접근 방법을 사용할 수 있다.

        ```sql
        EXPLAIN
        SELECT * FROM dept_emp WHERE dept_no = 'd005' AND emp_no = 10001;
        +----+-------------+----------+------------+-------+---------------------------+---------+---------+-------------+------+----------+-------+
        | id | select_type | table    | partitions | type  | possible_keys             | key     | key_len | ref         | rows | filtered | Extra |
        +----+-------------+----------+------------+-------+---------------------------+---------+---------+-------------+------+----------+-------+
        |  1 | SIMPLE      | dept_emp | NULL       | const | PRIMARY,ix_empno_fromdate | PRIMARY | 20      | const,const |    1 |   100.00 | NULL  |
        +----+-------------+----------+------------+-------+---------------------------+---------+---------+-------------+------+----------+-------+
        ```

    - 실행 계획의 type이 const 인 경우, 옵티마이저가 쿼리를 최적화하는 단계에서 쿼리를 먼저 실행해서 상수화한다.

        ```sql
        EXPLAIN
        SELECT COUNT(*)
        FROM employees e1
        WHERE first_name = (
            SELECT first_name FROM employees e2 WHERE emp_no = 10001
        );
        
        +----+-------------+-------+------------+-------+---------------+--------------+---------+-------+------+----------+--------------------------+
        | id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref   | rows | filtered | Extra                    |
        +----+-------------+-------+------------+-------+---------------+--------------+---------+-------+------+----------+--------------------------+
        |  1 | PRIMARY     | e1    | NULL       | ref   | ix_firstname  | ix_firstname | 58      | const |  253 |   100.00 | Using where; Using index |
        |  2 | SUBQUERY    | e2    | NULL       | const | PRIMARY       | PRIMARY      | 4       | const |    1 |   100.00 | NULL                     |
        +----+-------------+-------+------------+-------+---------------+--------------+---------+-------+------+----------+--------------------------+
        
        -- // 실제 옵티마이저가 최적화되는 시점에 변환되는 쿼리
        SELECT COUNT(*)
        FROM employees e1
        WHERE first_name = 'Georgi'
        ```

3. `**eq_ref**`
    - **조인 쿼리에서 드라이빙 테이블의 칼럼 값을 드리븐 테이블의 프라이머리 키나 유니크 키로 검색 조건에 사용되는 실행 계획에서 표시된다.**
        - 두 번째 이후에 읽히는 테이블의 유니크 인덱스는 `NOT NULL` 이어야 한다.
        - 다중 컬럼으로 만들어진 프라이머리 키나 유니크 인덱스라면 모든 칼럼이 비교 조건에 사용되어야 한다.
        - 두 번째 이후에 읽는 테이블은 반드시 1건만 존재해야 한다는 보장이 있어야 한다.

        ```sql
        EXPLAIN
        SELECT *
        FROM dept_emp de, employees e
        WHERE e.emp_no = de.emp_no AND de.dept_no = 'd005';
        +----+-------------+-------+------------+--------+---------------------------+---------+---------+------------------+--------+----------+-------+
        | id | select_type | table | partitions | type   | possible_keys             | key     | key_len | ref              | rows   | filtered | Extra |
        +----+-------------+-------+------------+--------+---------------------------+---------+---------+------------------+--------+----------+-------+
        |  1 | SIMPLE      | de    | NULL       | ref    | PRIMARY,ix_empno_fromdate | PRIMARY | 16      | const            | 165571 |   100.00 | NULL  |
        |  1 | SIMPLE      | e     | NULL       | eq_ref | PRIMARY                   | PRIMARY | 4       | testdb.de.emp_no |      1 |   100.00 | NULL  |
        +----+-------------+-------+------------+--------+---------------------------+---------+---------+------------------+--------+----------+-------+
        ```

4. `**ref**`
    - **인덱스의 종류와 관계 없이 동등 조건으로 검색할 때는 ref 접근 방법이 사용된다.**
    - `eq_ref`와 달리 조인의 순서와 관계 없이 사용되며, 프라이머리 키나 유니크 키 제약 조건도 없다.
    - 동등 조건으로만 비교되므로 매우 빠른 레코드 조회 방법이다.

        ```sql
        EXPLAIN
        SELECT * FROM dept_emp WHERE dept_no = 'd0005';
        +----+-------------+----------+------------+------+---------------+---------+---------+-------+------+----------+-------------+
        | id | select_type | table    | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |
        +----+-------------+----------+------------+------+---------------+---------+---------+-------+------+----------+-------------+
        |  1 | SIMPLE      | dept_emp | NULL       | ref  | PRIMARY       | PRIMARY | 16      | const |    1 |   100.00 | Using where |
        +----+-------------+----------+------------+------+---------------+---------+---------+-------+------+----------+-------------+
        ```


    **→ const, eq_ref, ref 모두 WHERE 조건절에 사용하는 비교 연산자는 동등 비교 연산자(`=` 또는 `<=>`)여야 하며, 이 세 가지 방법은 성능상 문제를 일으키지 않는 방법이다.**

5. `**fulltext**`
    - **MySQL 서버의 전문 검색(Full-text Search) 인덱스를 사용해 레코드를 읽는 접근 방법이다.**
    - 전문 검색 인덱스는 통계 정보가 관리되지 않으며, 전문 검색 인덱스를 사용하려면 전혀 다른 SQL 인덱스를 사용해야 한다.
    - MySQL에서 전문 검색 인덱스는 우선순위가 상당히 높은데, 경험상 **인덱스를 이용하는 range 방식에 비해 빠르지 않다.**

        ```sql
        CREATE TABLE employee_name (
            emp_no INT NOT NULL,
            first_name VARCHAR(14) NOT NULL,
            last_name VARCHAR(16) NOT NULL,
            PRIMARY KEY (emp_no),
            FULLTEXT KEY fx_name (first_name, last_name) WITH PARSER ngram
        ) ENGINE=InnoDB;
        
        -- // type이 const인 경우 전문 검색 인덱스를 사용하지 않음
        EXPLAIN
        SELECT *
        FROM employee_name
        WHERE emp_no = 10001
          AND emp_no BETWEEN 10001 AND 10005
          AND MATCH(first_name, last_name) AGAINST ('Facello' IN BOOLEAN MODE);
        +----+-------------+---------------+------------+-------+-----------------+---------+---------+-------+------+----------+-------------+
        | id | select_type | table         | partitions | type  | possible_keys   | key     | key_len | ref   | rows | filtered | Extra       |
        +----+-------------+---------------+------------+-------+-----------------+---------+---------+-------+------+----------+-------------+
        |  1 | SIMPLE      | employee_name | NULL       | const | PRIMARY,fx_name | PRIMARY | 4       | const |    1 |    11.11 | Using where |
        +----+-------------+---------------+------------+-------+-----------------+---------+---------+-------+------+----------+-------------+
        
        -- // type이 rage인 경우 전문 검색 인덱스 사용
        EXPLAIN
        SELECT *
        FROM employee_name
        WHERE emp_no BETWEEN 10001 AND 10005
          AND MATCH(first_name, last_name) AGAINST ('Facello' IN BOOLEAN MODE);
        +----+-------------+---------------+------------+----------+-----------------+---------+---------+-------+------+----------+-----------------------------------+
        | id | select_type | table         | partitions | type     | possible_keys   | key     | key_len | ref   | rows | filtered | Extra                             |
        +----+-------------+---------------+------------+----------+-----------------+---------+---------+-------+------+----------+-----------------------------------+
        |  1 | SIMPLE      | employee_name | NULL       | fulltext | PRIMARY,fx_name | fx_name | 0       | const |    1 |   100.00 | Using where; Ft_hints: no_ranking |
        +----+-------------+---------------+------------+----------+-----------------+---------+---------+-------+------+----------+-----------------------------------+
        ```

6. `**ref_or_null**`
    - `**ref`에서 NULL 비교가 추가된 방법이다.**

        ```sql
        EXPLAIN
        SELECT * FROM titles
        WHERE to_date = '1985-03-01' 
          OR to_date IS NULL;
        +----+-------------+--------+------------+-------------+---------------+-----------+---------+-------+------+----------+--------------------------+
        | id | select_type | table  | partitions | type        | possible_keys | key       | key_len | ref   | rows | filtered | Extra                    |
        +----+-------------+--------+------------+-------------+---------------+-----------+---------+-------+------+----------+--------------------------+
        |  1 | SIMPLE      | titles | NULL       | ref_or_null | ix_todate     | ix_todate | 4       | const |    2 |   100.00 | Using where; Using index |
        +----+-------------+--------+------------+-------------+---------------+-----------+---------+-------+------+----------+--------------------------+
        ```

7. `**unique_subquery**`
    - WHERE 조건절에 사용될 수 있는 IN(s
    - **서브쿼리에서 중복되지 않는 유니크한 값만 반환할 때 이 접근 방법을 사용한다.**

    ```sql
    EXPLAIN
    SELECT * FROM departments
    WHERE dept_no IN ( SELECT dept_no FROM dept_emp WHERE emp_no = 10001 );
    +----+-------------+-------------+------------+--------+---------------------------+-------------------+---------+-------------------------+------+----------+-------------+
    | id | select_type | table       | partitions | type   | possible_keys             | key               | key_len | ref                     | rows | filtered | Extra       |
    +----+-------------+-------------+------------+--------+---------------------------+-------------------+---------+-------------------------+------+----------+-------------+
    |  1 | SIMPLE      | dept_emp    | NULL       | ref    | PRIMARY,ix_empno_fromdate | ix_empno_fromdate | 4       | const                   |    1 |   100.00 | Using index |
    |  1 | SIMPLE      | departments | NULL       | eq_ref | PRIMARY                   | PRIMARY           | 16      | testdb.dept_emp.dept_no |    1 |   100.00 | NULL        |
    +----+-------------+-------------+------------+--------+---------------------------+-------------------+---------+-------------------------+------+----------+-------------+
    
    -- // MySQL 8.0 버전에서 세미조인을 최적화 하는 기능이 추가되어, 세미 조인 최적화 옵션을 off로 변경한다.
    SET optimizer_switch = 'semijoin=off';
    +----+-------------+-------------+------------+------+---------------------------------------+-------------------+---------+-------+------+----------+-------------+
    | id | select_type | table       | partitions | type | possible_keys                         | key               | key_len | ref   | rows | filtered | Extra       |
    +----+-------------+-------------+------------+------+---------------------------------------+-------------------+---------+-------+------+----------+-------------+
    |  1 | PRIMARY     | departments | NULL       | ALL  | NULL                                  | NULL              | NULL    | NULL  |    9 |   100.00 | Using where |
    |  2 | SUBQUERY    | dept_emp    | NULL       | ref  | PRIMARY,ix_fromdate,ix_empno_fromdate | ix_empno_fromdate | 4       | const |    1 |   100.00 | Using index |
    +----+-------------+-------------+------------+------+---------------------------------------+-------------------+---------+-------+------+----------+-------------+
    ```

8. `**inddex_subquery**`
    - IN (subquery)는 괄호 안에 있는 값의 목록에서 중복된 값을 제거한다.
    - unique_subquey는 중복된 값이 없으므로 별도의 중복을 제거할 필요가 없지만 그렇지 않은 경우에는 중복된 값을 제거해야 한다.
    - **IN (subquery)에서 중복된 값을 제거할 때 인덱스를 이용할 수 있는 경우 index_subquery 방식이 사용된다.**
9. `**range**`
    - **인덱스 레인지 스캔 형태의 방법이다.**
    - range는 범위로 검색하는 경우를 의미하는데, 주로  `<`, `>`, `IS NULL`, `BETWEEN`, `IN`, `LIKE` 등의 연산자를 이용해 인덱스를 검색할 때 사용된다.
    - **일반적으로 애플리케이션의 쿼리가 가장 많이 사용하는 접근 방법인데, rage 접근 방법도 상당히 빠르므로 이 방법만 사용해도 성능이 보장된다.**
    - 또한, 일반적으로 인덱스 레인지 스캔은 const, ref, range 세 가지 접근 방법을 구분 없이 묶어서 지칭한다.

        ```sql
        EXPLAIN
        SELECT * FROM employees WHERE emp_no BETWEEN 10002 AND 10004;
        +----+-------------+-----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
        | id | select_type | table     | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
        +----+-------------+-----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
        |  1 | SIMPLE      | employees | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    3 |   100.00 | Using where |
        +----+-------------+-----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
        ```

10. `**index_merge**`
    - **2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어 낸 후, 그 결과를 병합해서 처리하는 방식이다.**
    - index_merge 접근 방법의 특징
        - 여러 인덱스를 읽어야 하므로 일반적으로 range 접근 방법보다 효율성이 떨어진다.
        - 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge가 적용되지 않는다.
        - index_merge로 처리된 결과는 2개 이상의 집합이 되기 때문에 교집합, 합집합, 또는 중복 제거와 같은 부가적인 작업이 필요하다.

        ```sql
        -- // emp_no는 프라이머리 키를 이용해 조회하고, first_name은 ix_fistname 인덱스를 이용해 조회한 후 두 결과를 병합
        EXPLAIN
        SELECT * FROM employees
        WHERE emp_no BETWEEN 10001 AND 11000
          OR first_name = 'Smith';
        +----+-------------+-----------+------------+-------------+----------------------+----------------------+---------+------+------+----------+------------------------------------------------+
        | id | select_type | table     | partitions | type        | possible_keys        | key                  | key_len | ref  | rows | filtered | Extra                                          |
        +----+-------------+-----------+------------+-------------+----------------------+----------------------+---------+------+------+----------+------------------------------------------------+
        |  1 | SIMPLE      | employees | NULL       | index_merge | PRIMARY,ix_firstname | PRIMARY,ix_firstname | 4,58    | NULL | 1001 |   100.00 | Using union(PRIMARY,ix_firstname); Using where |
        +----+-------------+-----------+------------+-------------+----------------------+----------------------+---------+------+------+----------+------------------------------------------------+
        ```

11. `**index**`
    - **index 접근 방법은 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미한다.**
    - 인덱스 풀 스캔은 풀 테이블 스캔 방식과 비교하는 레코드 건수는 같지만, 일반적으로 인덱스가 데이터 파일 전체보다 작으므로 풀 테이블 스캔보다 빠르다.
    - index 접근 방법은 다음 조건중 1,2를 충족하거나 1,3을 충족하는 쿼리에서 사용된다.

        1) range, const, ref 같은 접근 방법으로 인덱스를 사용하지 못하는 경우

        2) 인덱스에 포함된 칼럼만으로 처리할 수 있는 쿼리인 경우 (즉, 데이터 파일을 읽지 않아도 되는 경우)

        3) 인덱스를 이용해 정렬이나 그루핑 작업이 가능한 경우 (즉, 별도의 정렬 작업을 피할 수 있는 경우)

        ```sql
        EXPLAIN
        SELECT * FROM departments ORDER BY dept_name DESC LIMIT 10;
        ```

        - 위 쿼리는 LIMIT 조건이 있기 때문에 효율적이지만, **LIMIT 조건이 없거나 레코드 건수가 많아지면 상당히 느린 처리르 수행한다.**
12. `**ALL**`
    - **풀 테이블 스캔을 의미하는 접근 방법이다.**
    - 풀 테이블 스캔은 처음부터 끝까지 전부 읽어서 (체크 조건이 존재할 때) 불필요한 레코드를 제거하고 반환한다.
    - **풀 테이블 스캔은 가장 마지막에 선택하는 가장 비효율적인 방법이다.**
    - InnoDB는 풀 테이블 스캔이나 인덱스 풀 스캔과 같은 대량의 I/O를 유발하는 작업을 위해 한꺼번에 많은 페이지를 읽어들이는 “리드 어헤드” 기능을 제공한다.
        - MySQL 서버는 인접한 페이지가 연속해서 읽히면 백그라운드 읽기 스레드에서 최대 64개의 페이지씩 한꺼번에 읽을 수 있다.
        - `innodb_read_ahead_threshold`, `innodb_random_read_ahead` 시스템 변수를 이용해 리드 어헤드 실행을 제어할 수 있다.

      → 쿼리를 튜닝할 때, 무조건 인덱스 풀 스캔이나 테이블 풀 스캔을 제거하는 것이 아니라 쿼리의 성능을 확인해보고 적용해야 한다.