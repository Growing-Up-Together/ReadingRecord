# 8장 인덱스

## 8.1 디스크 읽기 방식

- 데이터비에스의 성능 튜닝은 어떻게 `디스크I/O` 를 줄이는냐가 관건이다

### 8.1.1 HDD vs SSD

- CPU나 메모리 같은 장치는 전자식 장치지만 하드 디스크 드라이브는 기계식 장치라 `병목 현상` 을 일으킨다
- HDD는 데이터 저장용 플래터를 사용하고, SSD는 플래시 메모리를 사용한다
- SSD는 HDD보다 `랜덤I/O` 가 훨씬 빠르다
- 데이터베이스 서버에서는 `랜덤I/O` 의 비중이 크기 때문에 SSD가 DBMS용 스토리지에 최적이다

### 8.1.2 랜덤 I/O와 순차 I/O

- `순차I/O` 는 3개의 페이지를 디스크에 기록하기 위해 1번 요청하지만 `랜덤I/O` 는 3번 요청을한다
    - 디스크를 기록할 때 순차I/O는 디스크 헤더를 1번 움직이지만, 랜덤I/O는 3번 움직여야 한다
- SSD에서도 랜덤I/O는 순차I/O보다 전체 스루풋이 떨어진다
- 쿼리 튜닝은 `랜덤I/O` 자체를 줄여주는 것이 목적이다 ⇒ 필요한 데이터만 읽도록 쿼리를 개선한다

## 8.2 인덱스란?

- 인덱스는 `색인` 이다
- `SortedList` 는 DMBS의 인덱스와 같은 자료구조이고, `ArrayList` 는 데이터 파일과 같은 자료 구조
- 인덱스의 장/단점
    - 저장하는 과정은 복잡하고 느리지만, 이미 정렬돼 있어 아주 빨리 원하는 값을 찾아올 수 있다
        - `insert`, `update` , `delete`  처리가 느려진다
    - 읽기 속도를 높여준다
- 인덱스의 역할로 `프라이머리 키 인덱스` 와 `세컨더리 키 인덱스` 로 구분한다
    - 프라이머리 키는 레코드를 대표하는 컬럼으로 만들어진 인덱스
    - 레코드 식별할 수 있는 기준값으로 식별자라고 한다
    - `Null` 을 허용하지 않고 `중복`을 허용하지 않는다
- 데이터 저장 방식으로 `B-Tree인덱스` , `Hash 인덱스` 로 구분된다
    - `B-Tree 인덱스` 는 가장 일반적으로 사용되는 인덱스 알고리즘이다
        - 값을 변형하지 않고, 원래의 값을 이용해 인덱싱한다
    - `Hash 인덱스` 알고리즘은 칼럼의 값으로 해시값을 계산헤서 인덱싱한다 ⇒ 매우 빠른 검색을 지원한다
        - 메모리 기반의 데이터베이스에서 많이 사용한다
- 데이터 중복 허용 여부로 `유니크 인덱스` , `유니크 아닌 인덱스` 로 구분한다
    - 유니크 인덱스는 옵티마이저에게 동등 조건에 대해 1건의 결과만 찾는 것이라고 알려준다
- 인덱스의 기능별로 분류하면 `전문 검색용 인덱스`, `공간 검색용 인덱스` 로 구분한다

## 8.3 B-Tree 인덱스

- `Balanced` 인덱스
- 컬럼의 원래 값을 변혈 시키지 않고 구조체 내에서 항상 정렬된 상태를 유지한다

### 8.3.1 구조 및 특징

![chapter8_img01.png](../images/haedoang/chapter8_img01.png)

- 리프 노드는 실제 데이ㅓ 레코드의 `실제 주소값` 을 가지고 있다
- 인덱스의 키 값은 정렬돼 있지만, 데이터 파일의 레코드는 임의의 순서로 저장돼 있다
- 데이터 파일은 `INSERT` 순서대로 저장되지 않는다
    - 레코드가 삭제되어 빈 공간이 생기면 재활용한다

### MyISAM vs InnoDB 인덱스

- MyISAM
    - 리프 노드가 `물리적 주소값`을 가진다
    - `ROWID` 로 INSERT된 순번이거나 데이터 파일 내의 위치(Offset)이다
- InnoDB
    - 인덱스에 저장돼있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한다

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제

### 8.3.3.1 인덱스 키 추가

- 새로운 키 값이 B-Tree에 저장될 떄 즉시 인덱스에 저장될 수도 있고 안될 수 도 있다
- MyISAM이나 MEMORY 스토리지 엔진에서는 `INSERT` 문장이 즉시 인덱스에 변겨오딘다
- InnoDB는 `체인지 버퍼` 를 이용해서 키 추가 작업을 지연한다

### 8.3.3.2 인덱스 키 삭제

- B-Tree 리프 노드에 삭제 마크만 하면 된다

### 8.3.3.3 인덱스 키 변경

- 먼저 키 값을 삭제한 후, 다시 새로운 키를 추가한다
- 체인지 버퍼를 활용해 지연 처리할 수 있다

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

### 8.3.3.1 인덱스 키 값의 크기

- InnoDB 스토리지 엔진의 디스크에 데이터를 저장하는 가장 기본적인 단위는 `페이지` 또는 `블록` 이다
- B-Tree 자식 노듸의 개수는 가변적이며, 인덱스의 페이지의 크기와 키 값의 크기로 결정된다

### 8.3.3.2 B-Tree 깊이

- 인덱스 키 값의 크기가 커질수록 B-Tree 깊이는 깊어진다

### 8.3.3.3 선택도(기수성)

- 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다

### 8.3.3.4 읽어야 하는 레코드의 건수

- DBMS의 옵티마이저는 20~ 25%를 넘어서면 인덱스를 이용하지 않는다
    - 강제로 인덱스를 사용하도록 힌트를 추가해도 성능상 얻을 수 있는 이점은 없다

### 8.3.4 B-Tree 인데스를 통한 읽기

### 8.3.4.1 인덱스 레인지 스캔

![chapter8_img02.png](../images/haedoang/chapter8_img02.png)

- 대표적인 접근 방식으로 가장 빠르다
- 검색해야할 인덱스의 범위가 결정됐을 때 사용하는 방식

![chapter8_img03](../images/haedoang/chapter8_img03.png)

- 인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이ㅓ 파일에서 레코드를 읽어오는 과정이 필요하다-
- 인덱스를 통해 읽을 데이터가 20 ~ 25%를 넘으면 인덱스보다 데이터를 직접 읽는 것이 효율적이다

### 8.3.4.2 인덱스 풀 스캔

![Untitled](../images/haedoang/Untitled%202.png)

- 인덱스를 사용하지만 인덱스의 첨부터 끝까지 읽는 방식
    - 테이블 풀 스캔보다 성능이 좋다 ⇒ 사실 당연한..

### 8.3.4.3 루스 인덱스 스캔

- 8.0버전부터 지원하며 느슨하게 또는 듬성등성하게 인덱스를 읽는 것을 의미한다
- `GROUP BY` 또는 `집합 함수` (MIN, MAX) 최적화하는 경우 사용한다

### 8.3.4.4. 인덱스 스킵 스캔

- 인덱스를 구성하는 컬럼의 순서가 매우 중요하다
- 8.0 버전부터 WHERE 조건절의 검색을 위해 사용 가능하도록 최적화가 되었다

### 8.3.5 다중 컬럼(Multi-column) 인덱스

- 두 개 이상의 컬럼으로 구성된 인덱스를 다중 컬럼 인덱스라고 한다
- 루프 노드와 리프 노드는 항상 존재한다
- 인덱스의 두 번째 칼럼은 첫 번째 칼럼에 의존해서 정렬되어 있다

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

- 인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저에 실시간을 만들어 실행 계획에 따라 결정된다

### 8.3.6.1 인덱스 정렬

- 8.0 버전부터 혼합 인덱스를 지원한다
    - CREATE INDEZX ix_team_name_userscore ON employeees (team_name ASC, user_score DESC

### 8.3.6.1.1 인덱스 스캔 방향

### 8.3.6.2 내림차순 인덱스

- 역순 정렬 쿼리가 정순 쿼리 보다 `28%` 더 시간이 걸린다 ⇒ 예제에서 한함
- 느린 이유
    - 페이지 잠금이 인덱스 정순에 적합한 구조이다
    - 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조이

### 8.3.7 B-Tree 인덱스의 가용성과 효율성

- 쿼리의 Where 조건 이나 GROUP BY, 또는 ORDER BY절이 어떤 경우에 인덱스를 사용할 수 있고 어떤 방시긍로 사용할 수 있는지 식별해야 한다

### 8.3.7.1 비교 조건의 종류와 효율성

- `작업 범위 결정 조건` , `필터링 조건` 으로 구분되며 작업 범위 결정 조건은 쿼리 성능을 높여준다

### 8.3.7.2 인덱스의 가용성

- B-Tree 인덱스의 특징은 `왼쪽 값에 기준해서 정렬`돼어 있다

### 8.3.7.3 가용성과 효율성 판단

- B-Tree 인데스를 사용할 수 없는 경우
    - NOT_EQUAL(<>, NOT IN, NOT BETWEEN, IS NOT NULL)
    - LIKE %??
    - 스토어드 함수나 다른 연산자로 변형된 경우
    - NOT_ETERMINISTIC 속성의 스토어드 함수가 비교 조건으로 사용된 경우
    - 데이터 타입이 서로 다른 경우 비교
    - 문자열 데이터 타입의 콜레이션이 다른 경우