# ✏️ 스터디 기록

> 스터디 일시 : 2023.01.17  
> 서기: 위니

<br />

## 11장. 쿼리 작성 및 최적화

> 11.8 GROUP BY ~ 11.4.13 잠금을 사용하는 SELECT

<br />

### 학습 내용

---

#### GROUP BY

- `GROUP BY` 와 함께 `WITH ROLLUP` 을 사용할 수 있다.
- (레코드 → 칼럼 변환) 또는 (하나의 칼럼 → 여러 칼럼) 분리하는 등의 작업이 필요한 경우
    - `집합 함수` 또는 `CASE...WHEN` 구문을 통해 SQL을 작성하면 된다.

#### ORDER BY

- 기본적으로 `SELECT` 쿼리는 순서를 보장하지 않는다.
- 정렬이 필요하다면 `ORDER BY`를 사용하자.
- 정렬이 이루어진 쿼리는 Extra 칼럼에 "Using Filesort"가 표시된다.
- `ORDER BY` 절에 문자 리터럴은 무시된다.
- MySQL 8.0 부터 정렬 순서를 혼횽해서 인덱스를 생성할 수 있다.

#### 서브 쿼리

- `MySQL 5.6` 버전까지는 서브쿼리를 최적으로 실행하지 못한다.
- `MySQL 8.0` 버전부터는 서브쿼리가 많이 최적화 되었다.
- 서브쿼리가 사용되는 위치(`SELECT`, `FROM`, `WHERE`)에 따라 최적화 방법이 달라진다.
- 조인으로 처기 가능한 쿼리는 조인으로 실행하는 것이 좋다.
- 동일한 서브쿼리가 여러번 사용되는 경우 래터럴 조인을 사용하는 것이 좋다. (MySQL 8.0 부터 가능)
- `MySQL 5.7` 버전부터 `FROM` 절의 서브쿼리를 외부 쿼리로 병합하는 최적화를 수행하도록 최적화되었다.
- `WHERE` 절의 서브쿼리는 `동등 또는 크다 작다 비교`, `IN 비교`, `NOT IN 비교` 3가지로 구분된다.
- `IN(subquery)` 절을 세미 조인이라고 부르는데, `MySQL 5.5` 버전까지 세미 조인의 최적화가 매우 부족해서 대부분 풀테이블 스캔을 사용하게 된다.

#### CTE

- 재귀적 반복 실행 여부를 기준으로 `비 재귀적 CTE`와 `재귀적 CTE`로 나눌 수 있다.
- CTE의 장점
    - CTE는 재사용이 가능하기 때문에 `FROM` 절의 서브쿼리보다 효율적이다.
    - CTE로 선언된 임시 테이블을 다른 CTE 쿼리에서 참조할 수 있다.
    - CTE는 임시 테이블의 생성 부분과 사용 부분의 코드를 분리할 수 있으므로 가독성이 높다.
- 재귀적 CTE 쿼리
    - `비 재귀적 쿼리` + `(UNION | UNION DISTINCT | UNION ALL)` + `재귀적 쿼리` 로 구성된다.
    - 재귀적 CTE가 무한 반복하지 않기 위해 `cte_max_recursion_depth` 변수를 낮게 설정하자.

#### 윈도우 함수

- 집계함수는 그룹별로 하나의 레코드를 묶어서 출력하기 때문에 결과 집합의 모양이 변하지만, 윈도우 함수는 그대로 유지한다.
- 윈도우 함수의 실행 순서
    - `WHERE` → `FROM` → `GROUP BY` → `ORDER BY` → **`윈도우 함수`** → `SELECT` → `ORDER BY` → `LIMIT`
- 윈도우 함수 기본 사용법
    - `AGGREGATE_FUNC() OVER(<partition> <order>) AS window_func_column`
- 윈도우 함수의 각 파티션 안에서 프레임이라고 하는 연산을 수행하는 소그룹이 사용된다. (프레임을 지정하지 않아도 MySQL에서 상황에 맞게 프레임을 선택한다.)
- 윈도우 함수에는 집계 함수와 비 집계 함수를 모두 사용할 수 있다.
    - 비 집계 함수는 반드시 `OVER()` 절을 가지고 있어야 하며, 윈도우 함수로만 사용될 수 있다.

#### 잠금을 사용하는 SELECT

- 기본적으로 InnoDB는 `SELECT`할 때 아무런 잠금도 걸지 않는다.
- `SELECT` 절에서 `FOR SHARE`, `FOR UPDATE`를 사용하면 잠금을 걸 수 있다.  
  - `FOR SHARE`: 읽기 잠금
  - `FOR UPDATE`: 쓰기 잠금
- `OF 테이블` 옵션을 주면 명시적으로 테이블을 지정해서 잠금을 걸 수 있다.
- `NO WAIT`는 레코드가 잠긴 상태라도 무시하고 즉시 에러를 반환한다.
- `SKIP LOCKED`는 잠금이 걸리지 않은 레코드만 가져온다.

### Issue

--- 

- `CTE`를 사용하면 자체적으로 인덱스를 생성해서 수행한다고 함
- 
- `2권 p.103~104` MySQL 8.0 버전부터는 오름차순과 내림차순을 혼용해서 인덱스를 생성할 수 있게 개선됐다.  
  `1권 p.243` MySQL 8.0의 내림차순 인덱스로만 해결될 수 있다. → 이해가 안됨!
  - 인덱스를 `ASC` 방향으로 생성하면 ASC(정순 스캔)든 DESC(역순 스캔)든 비용 차이가 거의 없다.
  - 인덱스를 `DESC` 방향으로 생성하면 DESC(정순 스캔)가 ASC(역순 스캔)보다 더 빠르다.

### 질문

---

- `p.109` 래터럴 조인의 버그
  - 실행계획을 확인하고 사용하자.

- `p.137` 윈도우 함수도 인덱스를 제대로 처리하지 못하는 부분이 있다.
  - 가능하면 윈도우 함수 주의해서 사용하자.

### 다음주 공지

---

✔️ 다음주는 명절로 한 주 쉬어갑니다. 설날 잘 보내세요~😀   
✔️ 다음 모임은 `1/31 21:00`에 만나요!
✔️ `1/31` 회고를 합시다~!
