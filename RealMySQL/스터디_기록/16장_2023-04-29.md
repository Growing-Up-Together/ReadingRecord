# ✏️ 스터디 기록

- 스터디 일시 : 2023.04.29
- 서기: 김해동

## 16장. 복제

### 학습 내용

- 16.4 복제 데이터 포맷
    - Statement 기반 바이너리 로그
        - 변경 이벤트에 대해 SQL문을 저장하는 방식
        - 로그 저장 공간이 작아진다 
        - 비확정적 쿼리 수행 시 소스 서버와 레플리카 서버간 데이터가 달라질 수 있다 ex) UUID()
        - Row 기반 바이너리 로그보다 락이 더 많이 걸게 된다
        - `REPEATABLE-READ` 이상의 격리수준을 가져야 한다
    - Row 기반 바이너리 로그
        - 서버 데이터 변경 시 값 자체를 바이너리 로그에 기록하는 방식
        - 데이터 일관성
        - 락 점유가 적다
        - 로그 파일 크기가 커질 수 있다
    - Mixed 포맷
        - Statement + Row 
        - 기본적으로 Statement 포맷으로 저장. 문제가 될 경우 Row 포맷으로 변환되어 저장
    
    - Row 포맷의 용량 최적화
        - `binlog_row_image` 시스템 변수 사용
            - full, minimal, noblob
    - 바이너리 로그 트랜잭션 압축
        - 8.0.20버전부터 Row 포맷으로 기록되는 트랜잭션에 대해 데이터를 압축해서 기록할 수 있다
        - `binlog_transaction_compression` 
        - `zstd` 알고리즘을 사용한다
- 16.5 복제 동기화 방식
    - 비동기 복제
        - MySQL 기본 복제 방식 
        - 변경 이벤트가 적용되었는지 확인하지 않는 방식
    - 반동기 복제
        - 향상된 무결성을 제공하는 복제 방식
        - 변경 이벤트의 응답(ACK)을 확인하고 COMMIT 
        - `rpl_semi_sync_master_wait_point` 응답 지점을 제어할 수 있다
            - AFTER_SYNC 방식
                - 8.0 버전 기본 방식
                - 소스 서버 장애 발생했을 때 팬텀 리드가 발생하지 않음
                - 장애 발생한 소스 서버에 대해 수월하게 복구 처리 가능
            - AFTER_COMMIT 방식 
- 16.6 복제 토폴로지
    - 싱글 레플리카 복제 구성
        -  하나의 소스서버에 하나의 레플리카 서버
    - 멀티 레플리카 복제 구성
        - 하나의 소스서버에 2개 이상의 레플리카 서버
    - 체인 복제 구성
        - 1:M:M 구조
    - 듀얼 소스 복제 구성 
        - 두개의 MySQL 서버가 서로 소스서버이자 레플리카 서버로 구성
            - ACTIVE-PASSIVE 
                - 하나의 서버에서만 쓰기 작업을 수행
            - ACTIVE-ACTIVE 
                - 두 서버 모두 쓰기 작업 수행
                - 지리적으로 떨어진 위치에서 유입되는 쓰기 요청을 원활하게 처리
                - 동일한 데이터를 각 서버에서 변경할 경우 문제가 발생할 수 있다
                - 테이블에서 Auto-Increment 키 사용 시 문제가 발생할 수 있다
    - 멀티 소스 복제 구성
        - 하나의 레플리카 서버가 둘 이상의 소스 서버를 가지는 형태 
            
### Issue

- p.488) MySQL에서 `AFTER_SYNC` 반동기 복제 방식은 팬텀 리드가 발생하지 않는다고 하는데 innoDB 스토리지 엔진은 원래 팬텀 리드가 발생하지 않지 않나요 ?
    - InnoDB 스토리지 엔진은 일반적으로 팬텀 리드(Phantom Read)를 방지하기 위해 MVCC(Multi-Version Concurrency Control)라는 기술을 사용합니다. MVCC는 각 트랜잭션의 일관된 스냅샷을 사용하여 팬텀 리드를 방지하는 메커니즘입니다.
    - 하지만 AFTER_SYNC 반동기 복제 방식은 InnoDB 스토리지 엔진의 일반적인 작동 방식을 무시하고 MySQL의 복제 메커니즘을 통해 데이터를 복제합니다. 이 방식에서는 팬텀 리드가 발생할 수 있습니다.
    - AFTER_SYNC 복제 방식은 트랜잭션이 커밋된 이후에만 데이터를 복제하기 때문에, 해당 트랜잭션의 커밋 시점 이후에 발생한 다른 트랜잭션의 변경 사항도 반영될 수 있습니다. 따라서 팬텀 리드가 발생할 수 있습니다. 이는 복제된 노드에서는 AFTER_SYNC 방식으로 데이터를 받았지만, 해당 노드의 스냅샷에서는 다른 트랜잭션의 변경 사항이 반영되지 않아 팬텀 리드가 발생하는 것을 의미합니다.
    - 따라서, InnoDB 스토리지 엔진은 일반적으로 팬텀 리드를 방지하는 메커니즘을 갖추고 있지만, AFTER_SYNC 복제 방식은 MySQL의 복제 메커니즘에 의해 팬텀 리드가 발생할 수 있는 경우가 있습니다.

## 다음주 공지

✔️ 

<br>

# ⏳ 회고

## 좋았던 점

- 

## 아쉬웠던 점

- 

## 액션 플랜

- 