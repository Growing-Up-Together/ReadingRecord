# ✏️ 스터디 기록

- 스터디 일시 : 2022.09.15
- 서기: 해도앙

## 8장. 인덱스

### 학습 내용
- SSD는 HDD보다 랜덤I/O를 많이 사용하는 DBMS 스토리지에 최적화되어있다
- 인덱스는 `SortedList` 자료 구조와 동일한 특성을 가진다 => 조회 성능이 높다
- 인덱스는 프라이머리 키 인덱스와 세컨더리 인덱스로 구분한다
- B-Tree 알고리즘과 Hash 알고리즘이 시중의 RDBMS에서 많이 사용된다
- B-Tree 인덱스는 쓰기 작업에 비용이 많이 들고, 인덱스 삭제는 간단하다(마킹)
- B-Tree 인덱스 키 변경은 삭제 후 추가 작업으로 수행된다
- 인덱스를 사용하는 것은 레코드를 읽는 것은 높은 비용이 들기 때문에 테이블 전체 스캔보다 효율적일지 판단해야 한다
- B-Tree 인덱스는 `인덱스 레인지 스캔`, `인덱스 풀 스캔`, `루스 인덱스 스캔`, `인덱스 스킵 스캔` 이 있다
- `인덱스 스킵 스캔`은 유니크한 값의 개수가 작을수록 성능이 높아진다
- R-Tree 인덱스는 공간 데이터를 저장할 수 있는 데이터 타입을 가진다 => `2차원 데이터 인덱싱`
- R-Tree 인덱스는 `GEOMETRY` 타입은 `POINT`, `LINE`, `POLIGON`, `GEOMETRY` 로 구성된다
- 전문 검색 인덱스는 `문서 내용 전체를 인덱스화`하여 포함된 문서를 검색하는 인덱스이다
- n-gram 알고리즘은 `2-gram` 알고리즘이 많이 사용된다 
- 전문 검색 인덱스는 `MATCH ... AGAINST` 문법을 사용해야 한다
- MySQL8.0 부터 `가상 컬럼`, `함수`를 이용하여 함수기반 인덱스를 사용할 수 있다
- `멀티 밸류 인덱스`는 하나의 레코드가 여러 개의 키 값을 가질 수 있다 => JSON 타입 지원
- `클러스터링 인덱스`는 프라이머리 키 값에 대한 의존도가 높다 => 검색 성능이 좋다
    - `B-Tree 인덱스`와 다르게 클러스터링 인덱스는 리프 노드에 레코드의 모든 컬럼이 저장되어 있다
- `클러스터링 인덱스`는 프라이머리 키를 반드시 등록해서 사용하는 것을 권장한다 
- `유니크 인덱스`는 `null` 값은 허용된다
- `유니크 인덱스`와 `세컨더리 인덱스`는 구조적으로 차이가 없으며, 성능 차이 또한 미미하다
- `유니크 인덱스`는 중복 여부를 확인해야 하기 때문에 쓰기 성능이 세컨더리 인덱스보다 낮다
- `외래키`는 InnoDB 스토리지 엔진에서만 생성 가능하다
    - 테이블 변경 시 잠금 경합이 발생한다
    - 외래키와 연관되지 않은 칼럼의 변경 시는 잠금 경합이 발생하지 않는다
 
     

### 궁금한점

### Issue
- [p.248 B-Tree 인덱스 효율성](https://github.com/Growing-Up-Together/ReadingRecord/issues/24)
 - 인덱스의 첫번째를 기준으로 정렬되므로 두가지 조건을 먼저 만족하는 row 를 찾은 후 이후의 row들을 두가지 조건으로 모두 조회해야 한다
- [p.252 작업 범위 결정 조건 인덱스](https://github.com/Growing-Up-Together/ReadingRecord/issues/26)
 - 범위 결정 조건에 사용되지 않은 인덱스는 모두 `체크 조건`이 된다
- [p.257 R-Tree 인덱스 좌표 검색 예제](https://github.com/Growing-Up-Together/ReadingRecord/issues/25)
 - 예제의 좌표값이 실제 경도, 위도를 나타내는 것이 아니라 단순 숫자로 표현했기 때문에 오해의 소지가 있음 
  - `거리 5의 차이는 실제 5Km가 아님` 
 
### 질문
- 인덱스 풀 스캔 vs 테이블 풀 스캔
 - 인덱스 컬럼을 1번부터 실행하지 않더라도 인덱스를 사용할 수 있다(인덱스 풀 스캔)
 - [MySQL 실행 계획 참고](https://jeong-pro.tistory.com/243)

