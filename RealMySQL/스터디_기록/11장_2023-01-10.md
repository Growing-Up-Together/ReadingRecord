
# ✏️ 스터디 기록

- 스터디 일시 : 2023.01.10
- 서기: heedong

<br />

## 11장. 쿼리 작성 및 최적화
### 11.4 SELECT ~ 11.4.7 JOIN
<br />

### 학습 내용
- SELECT 절 처리 순서는 where, group by, distinct, having, order by, limit 
- 인덱스된 칼럼의 값을 변환없이 그대로 사용해야 WHERE, ORDER BY, GROUP BY절의 인덱스 사용 가능
- WHERE 조건은 작업 범위 조건과 결정 조건으로 구분 됨. WHERE 절에 선언된 조건의 순서와 인덱스의 순서는 상관없이 최적화 가능함. OR 조건 사용은 자제하는 것이 좋음.
-  GROUP BY 절에 명시된 칼럼이 인덱스 칼럼의 순서가 일치해야 인덱스 사용이 가능함.
- ORDER BY 절의 인덱스 사용 여부는 GROUP BY 와 거의 흡사함. ORDER BY 절에 정의된 칼럼의 정렬 순서가 동일 해야 함.
-  WHERE, ORDER BY 절이 동시에 같은 인덱스를 이용하는 것이 빠른 성능을 보이므로 튜닝에 효과적임.
- WHERE 조건의 NULL 비교 시, `ISNULL()` 함수를 이용하여 비교하는 것이 좋음. 문자열/숫자 칼럼 비교 시 상숫값을 비교하는 것이 좋음.
- 날짜 관련 타입들의 비교 시, 문자열로 비교하여도 인덱스 사용 가능. 데이터 변환이 필요한 경우는 우측의 상숫/문자열 값을 변경하여 사용하는 것이 좋음.
- MySQL 서버는 `Short-Circuit Evaluation` 방식을 사용해 순서대로 WHERE 조건을 비교함. 대신 인덱스 사용 가능 조건이 있다면 최우선으로 사용 됨.
- `LIMIT` 사용 시 필요한 레코드 준비가 완료되면 그 즉시 쿼리를 종료함. `LIMIT m, n` 쿼리 사용 시, 수치가 커지는 경우 성능에 영향을 미치므로 적절히 WHERE 조건을 추가하여 효율성을 높이는 것이 좋음.
- `COUNT(*)` 는 칼럼 전체가 아니라 레코드 자체를 의미하기 때문에 `COUNT(칼럼명)`은 동일함. `COUNT(칼럼명 or 표현식)` 은 NULL 이 아닌 레코드 건수를 반환함.
- `JOIN` 칼럼 간의 비교 시, 각 칼럼의 데이터 타입이 일치하지 않으면 인덱스 효율적으로 사용 불가. `CHAR -> VARCHAR`, `INT -> BIGINT`, `DATE -> DATETIME` 간의 불일치 문제는 발생하지 않음.
- MySQL 8.0 ~ `래터럴 조인` 기능을 이용해 특정 그룹별로 서브쿼리 실행 후 그 결과와 조인하는 것이 가능함.
- MySQL 8.0 ~ `해시 조인` 방식이 도입 됨. 이전 버전은 네스티드-루프 방식의 조인만 가능했음. 


### Issue && 주의
- 드리븐 테이블이 성능이 좋아야 함 -> `인덱스` 있는 테이블 -> `첫번째로 읽는 테이블`
- `페이징`을 위한 쿼리 시, `limit m,n` 사용 주의
- `CTE` 쿼리는 `WITH table_name AS ( query )` 형태로 사용하며, 다음장에서 학습 예정

### 질문
- 내장 함수 vs 윈도우 함수 차이가 뭔가요?

## 다음주 공지

